# Story 4.5: Installation and Setup Automation

## Story Overview
**Epic**: Epic 4 - CLI Tool & Developer Experience
**Story ID**: 4.5
**Story Type**: Core Feature
**Complexity**: Medium-High
**Sprint**: TBD

## User Story
As a developer,
I want seamless installation and setup with minimal manual configuration,
So that I can start using the tool immediately without complex setup procedures.

## Story Context

### Business Value
- Eliminates installation barriers and reduces time-to-first-success for new users
- Provides automated setup that handles dependencies, configuration, and environment preparation
- Delivers consistent installation experience across different platforms and environments
- Enables rapid adoption by reducing complexity of initial tool setup and configuration

### Dependencies
**Depends On:**
- Story 4.1: Core CLI Framework and Command Structure (CLI framework operational)
- Story 4.4: Configuration Management and Customization (configuration templates and validation)
- All Epic 1, 2, 3 components (complete system functionality for packaging)

**Enables:**
- Story 4.6: Developer Documentation and Examples (installation documentation and guides)
- Complete Epic 4 delivery with production-ready installation and deployment capabilities
- End-to-end user onboarding from installation to functional MCP server

### Technical Context
**Existing System Integration:**
- Integrates with: Python packaging system, configuration management, dependency management
- Technology: Python setuptools/pip, package distribution, system integration, cross-platform deployment
- Follows pattern: Python packaging conventions, automated setup, dependency resolution
- Touch points: Python environment, system dependencies, configuration files, installation validation

## Story Status
**Current Status**: ✅ Story 4.5: Installation and Setup Automation (Ready for Review)

**Completed Components:**
✅ Package distribution setup (setup.py, pyproject.toml, __version__.py)
✅ Installation automation scripts (InstallationManager, SystemCompatibilityChecker, UninstallationManager)
✅ System compatibility checking (Python version, platform, disk space, memory, permissions, dependencies)
✅ Cross-platform installer components (Windows, macOS, Linux support)
✅ Setup validation and health checks (comprehensive verification system)
✅ CLI integration (setup command with full options)
✅ Comprehensive test suite (75 test cases covering all components)
✅ Installation documentation (complete user guide with troubleshooting)

**Implementation Summary:**
- **Package Structure**: Complete Python package with proper entry points and metadata
- **Installation Manager**: Automated setup with directory creation, configuration initialization, and verification
- **Compatibility Checker**: System validation for Python version, platform, resources, and dependencies
- **Uninstaller**: Clean removal with selective preservation options
- **CLI Integration**: Full setup command with force, verify, and uninstall options
- **Testing**: Comprehensive test coverage for all installation components
- **Documentation**: Complete installation guide with troubleshooting and platform-specific instructions

## Acceptance Criteria

### Functional Requirements
1. **Pip-Installable Package Creation**
   - Create proper Python package structure with setuptools configuration and entry points
   - Support pip installation from PyPI with automatic dependency resolution and version management
   - Enable development installation with `pip install -e .` for local development and testing
   - Provide wheel and source distribution packaging for multiple deployment scenarios

2. **One-Command Setup and Initialization**
   - Implement setup command that initializes required directories and configuration files
   - Perform installation verification and system compatibility checking during setup
   - Create default configuration files with appropriate permissions and validation
   - Handle setup errors gracefully with clear guidance for resolution

3. **Cross-Platform Installation Support**
   - Support installation on macOS, Linux, and Windows per NFR6 cross-platform requirements
   - Handle platform-specific dependencies and system integration requirements
   - Provide platform-specific installation instructions and troubleshooting guidance
   - Test installation process on all supported platforms with automated validation

### Integration Requirements
4. **Virtual Environment and Global Installation Support**
   - Support both global system installation and virtual environment deployment
   - Provide clear guidance for virtual environment setup and best practices
   - Handle environment-specific configuration and dependency management
   - Enable isolation between multiple installations and versions

5. **System Dependencies and Compatibility Checking**
   - Verify Python version compatibility (3.9+ requirement) during installation
   - Check for required system libraries and dependencies with installation guidance
   - Provide compatibility checking for different operating system versions
   - Handle dependency conflicts and provide resolution guidance

6. **Automated Configuration and Environment Setup**
   - Initialize configuration directories and files during setup process
   - Create logging directories and configure appropriate permissions
   - Set up database and search index directories with proper structure
   - Generate initial configuration with sensible defaults based on detected environment

### Quality Requirements
7. **Installation Verification and Validation**
   - Provide installation verification command that validates complete system functionality
   - Test all major components and integration points during verification process
   - Generate installation report with system information and configuration validation
   - Support diagnostic mode for troubleshooting installation issues

8. **Clean Uninstallation and Cleanup**
   - Implement uninstallation script that properly cleans up all created files and configurations
   - Remove configuration directories, logs, and temporary files during uninstallation
   - Handle uninstallation conflicts and provide guidance for manual cleanup
   - Preserve user data and configurations with optional backup during uninstallation

9. **Installation Documentation and Guidance**
   - Provide comprehensive installation guide with step-by-step instructions
   - Include troubleshooting section for common installation issues and solutions
   - Create platform-specific installation notes and requirements documentation
   - Support offline installation scenarios with dependency bundling options

## Technical Implementation Notes

### Python Package Structure
```python
# setup.py - Main package configuration
from setuptools import setup, find_packages
import os
import sys

# Ensure Python version compatibility
if sys.version_info < (3, 9):
    sys.exit("Python 3.9 or higher is required")

def read_requirements(filename):
    """Read requirements from file"""
    with open(filename, 'r') as f:
        return [line.strip() for line in f if line.strip() and not line.startswith('#')]

def read_long_description():
    """Read long description from README"""
    with open("README.md", "r", encoding="utf-8") as f:
        return f.read()

setup(
    name="swagger-mcp-server",
    version="1.0.0",
    author="Universal Swagger MCP Server Team",
    author_email="support@swagger-mcp-server.com",
    description="Universal Swagger → MCP Server Converter",
    long_description=read_long_description(),
    long_description_content_type="text/markdown",
    url="https://github.com/swagger-mcp-server/swagger-mcp-server",

    packages=find_packages(where="src"),
    package_dir={"": "src"},

    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Topic :: Internet :: WWW/HTTP :: HTTP Servers",
        "Topic :: Documentation",
    ],

    python_requires=">=3.9",

    install_requires=read_requirements("requirements.txt"),

    extras_require={
        "dev": read_requirements("requirements-dev.txt"),
        "test": read_requirements("requirements-test.txt"),
    },

    entry_points={
        "console_scripts": [
            "swagger-mcp-server=swagger_mcp_server.cli:main",
        ],
    },

    include_package_data=True,
    package_data={
        "swagger_mcp_server": [
            "templates/*.yaml",
            "templates/*.json",
            "schemas/*.json",
        ],
    },
)

# pyproject.toml - Modern Python packaging
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools-scm"]
build-backend = "setuptools.build_meta"

[project]
name = "swagger-mcp-server"
dynamic = ["version"]
description = "Universal Swagger → MCP Server Converter"
readme = "README.md"
requires-python = ">=3.9"
license = {text = "MIT"}
authors = [
    {name = "Universal Swagger MCP Server Team", email = "support@swagger-mcp-server.com"}
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
dependencies = [
    "click>=8.0.0",
    "pyyaml>=6.0",
    "aiofiles>=0.8.0",
    "whoosh>=2.7.4",
    "cerberus>=1.3.4",
    "psutil>=5.8.0",
    "aiohttp>=3.8.0",
    "jsonref>=0.2",
    "openapi-spec-validator>=0.4.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "black>=22.0.0",
    "flake8>=5.0.0",
    "mypy>=1.0.0",
]

[project.scripts]
swagger-mcp-server = "swagger_mcp_server.cli:main"

[project.urls]
Homepage = "https://github.com/swagger-mcp-server/swagger-mcp-server"
Documentation = "https://docs.swagger-mcp-server.com"
Repository = "https://github.com/swagger-mcp-server/swagger-mcp-server"
Issues = "https://github.com/swagger-mcp-server/swagger-mcp-server/issues"
```

### Installation and Setup Commands
```python
import click
import os
import sys
import shutil
import platform
from pathlib import Path
from typing import Dict, Any, List
import subprocess
import tempfile

class InstallationManager:
    """Manages installation, setup, and verification processes"""

    def __init__(self):
        self.platform = platform.system().lower()
        self.python_version = sys.version_info
        self.install_dir = Path.home() / ".swagger-mcp-server"

    async def perform_setup(self, force: bool = False) -> Dict[str, Any]:
        """Perform complete system setup"""

        setup_results = {
            "steps_completed": [],
            "warnings": [],
            "errors": []
        }

        try:
            # Step 1: System compatibility check
            await self.check_system_compatibility()
            setup_results["steps_completed"].append("System compatibility verified")

            # Step 2: Create directory structure
            await self.create_directory_structure(force)
            setup_results["steps_completed"].append("Directory structure created")

            # Step 3: Initialize configuration
            await self.initialize_configuration()
            setup_results["steps_completed"].append("Configuration initialized")

            # Step 4: Verify installation
            verification_result = await self.verify_installation()
            setup_results["steps_completed"].append("Installation verified")

            if verification_result.get("warnings"):
                setup_results["warnings"].extend(verification_result["warnings"])

            return setup_results

        except Exception as e:
            setup_results["errors"].append(str(e))
            raise InstallationError(f"Setup failed: {str(e)}", setup_results)

@click.command()
@click.option("--force", "-f", is_flag=True,
              help="Force setup even if already initialized")
@click.option("--verify", "-v", is_flag=True,
              help="Verify installation without setup")
@click.option("--uninstall", is_flag=True,
              help="Uninstall and clean up all files")
@click.pass_context
async def setup(ctx: click.Context, force: bool, verify: bool, uninstall: bool):
    """Setup and installation management

    Initialize the swagger-mcp-server environment, create necessary directories,
    and configure the system for first use. This command handles all setup
    requirements automatically.

    Examples:
      # Initial setup
      swagger-mcp-server setup

      # Force re-setup (overwrites existing configuration)
      swagger-mcp-server setup --force

      # Verify existing installation
      swagger-mcp-server setup --verify

      # Clean uninstall
      swagger-mcp-server setup --uninstall
    """
    try:
        manager = InstallationManager()

        if uninstall:
            await handle_uninstall(manager)
            return

        if verify:
            await handle_verification(manager)
            return

        # Perform setup
        click.echo("🚀 Starting swagger-mcp-server setup...")

        # Check if already setup
        if manager.is_already_setup() and not force:
            click.echo("✅ System is already set up")
            click.echo("   Use --force to re-initialize or --verify to check installation")
            return

        # Perform setup steps
        result = await manager.perform_setup(force)

        # Display results
        click.echo("\n✅ Setup completed successfully!")
        click.echo("\nCompleted steps:")
        for step in result["steps_completed"]:
            click.echo(f"   ✓ {step}")

        if result["warnings"]:
            click.echo("\n⚠️  Warnings:")
            for warning in result["warnings"]:
                click.echo(f"   - {warning}")

        # Next steps guidance
        click.echo("\n🎉 Ready to use swagger-mcp-server!")
        click.echo("Next steps:")
        click.echo("   1. Convert a Swagger file: swagger-mcp-server convert api.json")
        click.echo("   2. Start MCP server: swagger-mcp-server serve")
        click.echo("   3. Check status: swagger-mcp-server status")

    except InstallationError as e:
        handle_installation_error(e, ctx)
    except Exception as e:
        handle_unexpected_error(e, ctx)

async def handle_verification(manager: InstallationManager):
    """Handle installation verification"""

    click.echo("🔍 Verifying swagger-mcp-server installation...")

    verification_result = await manager.verify_installation()

    if verification_result["status"] == "success":
        click.echo("✅ Installation verification successful!")

        # Display system information
        click.echo("\n📋 System Information:")
        sys_info = verification_result["system_info"]
        click.echo(f"   Platform: {sys_info['platform']}")
        click.echo(f"   Python: {sys_info['python_version']}")
        click.echo(f"   Installation: {sys_info['install_path']}")

        # Display component status
        click.echo("\n🧩 Component Status:")
        components = verification_result["components"]
        for component, status in components.items():
            status_emoji = "✅" if status["working"] else "❌"
            click.echo(f"   {status_emoji} {component}: {status['message']}")

    else:
        click.echo("❌ Installation verification failed!")
        click.echo("\nIssues found:")
        for issue in verification_result.get("issues", []):
            click.echo(f"   - {issue}")

        click.echo("\nTry running: swagger-mcp-server setup --force")
```

### System Compatibility and Dependency Checking
```python
class SystemCompatibilityChecker:
    """Checks system compatibility and dependencies"""

    async def check_system_compatibility(self) -> Dict[str, Any]:
        """Comprehensive system compatibility check"""

        compatibility_report = {
            "compatible": True,
            "issues": [],
            "warnings": [],
            "system_info": {}
        }

        # Python version check
        python_check = self.check_python_version()
        compatibility_report["system_info"]["python"] = python_check
        if not python_check["compatible"]:
            compatibility_report["compatible"] = False
            compatibility_report["issues"].append(python_check["message"])

        # Platform support check
        platform_check = self.check_platform_support()
        compatibility_report["system_info"]["platform"] = platform_check
        if not platform_check["supported"]:
            compatibility_report["compatible"] = False
            compatibility_report["issues"].append(platform_check["message"])

        # Disk space check
        disk_check = self.check_disk_space()
        compatibility_report["system_info"]["disk"] = disk_check
        if not disk_check["sufficient"]:
            compatibility_report["warnings"].append(disk_check["message"])

        # Memory check
        memory_check = self.check_memory()
        compatibility_report["system_info"]["memory"] = memory_check
        if not memory_check["sufficient"]:
            compatibility_report["warnings"].append(memory_check["message"])

        # Network connectivity (optional)
        network_check = await self.check_network_connectivity()
        compatibility_report["system_info"]["network"] = network_check
        if not network_check["available"]:
            compatibility_report["warnings"].append(network_check["message"])

        return compatibility_report

    def check_python_version(self) -> Dict[str, Any]:
        """Check Python version compatibility"""

        min_version = (3, 9)
        current_version = sys.version_info[:2]

        if current_version >= min_version:
            return {
                "compatible": True,
                "current": f"{current_version[0]}.{current_version[1]}",
                "required": f"{min_version[0]}.{min_version[1]}+",
                "message": f"Python {current_version[0]}.{current_version[1]} is supported"
            }
        else:
            return {
                "compatible": False,
                "current": f"{current_version[0]}.{current_version[1]}",
                "required": f"{min_version[0]}.{min_version[1]}+",
                "message": f"Python {min_version[0]}.{min_version[1]}+ required, found {current_version[0]}.{current_version[1]}"
            }

    def check_platform_support(self) -> Dict[str, Any]:
        """Check operating system support"""

        supported_platforms = ["windows", "darwin", "linux"]
        current_platform = platform.system().lower()

        if current_platform in supported_platforms:
            return {
                "supported": True,
                "platform": current_platform,
                "message": f"{platform.system()} is supported"
            }
        else:
            return {
                "supported": False,
                "platform": current_platform,
                "message": f"{platform.system()} is not officially supported"
            }

    def check_disk_space(self, required_mb: int = 100) -> Dict[str, Any]:
        """Check available disk space"""

        try:
            install_path = Path.home()
            disk_usage = shutil.disk_usage(install_path)
            available_mb = disk_usage.free / (1024 * 1024)

            if available_mb >= required_mb:
                return {
                    "sufficient": True,
                    "available_mb": int(available_mb),
                    "required_mb": required_mb,
                    "message": f"{int(available_mb)}MB available (≥{required_mb}MB required)"
                }
            else:
                return {
                    "sufficient": False,
                    "available_mb": int(available_mb),
                    "required_mb": required_mb,
                    "message": f"Insufficient disk space: {int(available_mb)}MB available, {required_mb}MB required"
                }

        except Exception:
            return {
                "sufficient": True,  # Assume sufficient if can't check
                "message": "Could not check disk space"
            }
```

### Uninstallation and Cleanup
```python
class UninstallationManager:
    """Handles clean uninstallation and file cleanup"""

    async def perform_uninstallation(self, preserve_config: bool = False) -> Dict[str, Any]:
        """Perform complete system uninstallation"""

        uninstall_results = {
            "removed_items": [],
            "preserved_items": [],
            "warnings": [],
            "errors": []
        }

        try:
            # Remove installation directory
            if self.install_dir.exists():
                if preserve_config:
                    await self.selective_cleanup(uninstall_results)
                else:
                    shutil.rmtree(self.install_dir)
                    uninstall_results["removed_items"].append(str(self.install_dir))

            # Remove package (if installed via pip)
            pip_result = await self.uninstall_pip_package()
            if pip_result["success"]:
                uninstall_results["removed_items"].append("pip package")
            else:
                uninstall_results["warnings"].append(pip_result["message"])

            # Clean up temporary files
            temp_cleanup = await self.cleanup_temp_files()
            uninstall_results["removed_items"].extend(temp_cleanup)

            return uninstall_results

        except Exception as e:
            uninstall_results["errors"].append(str(e))
            raise UninstallationError(f"Uninstallation failed: {str(e)}", uninstall_results)

    async def selective_cleanup(self, results: Dict[str, Any]):
        """Selective cleanup preserving user configuration"""

        # Remove cache directories
        cache_dirs = ["search_index", "__pycache__", ".cache"]
        for cache_dir in cache_dirs:
            cache_path = self.install_dir / cache_dir
            if cache_path.exists():
                shutil.rmtree(cache_path)
                results["removed_items"].append(f"cache: {cache_dir}")

        # Remove log files
        log_files = list(self.install_dir.glob("*.log"))
        for log_file in log_files:
            log_file.unlink()
            results["removed_items"].append(f"log: {log_file.name}")

        # Preserve configuration files
        config_files = ["config.yaml", "servers.json"]
        for config_file in config_files:
            config_path = self.install_dir / config_file
            if config_path.exists():
                results["preserved_items"].append(f"config: {config_file}")

async def handle_uninstall(manager: InstallationManager):
    """Handle uninstallation process"""

    click.echo("🗑️  Starting swagger-mcp-server uninstallation...")

    # Confirm uninstallation
    if not click.confirm("This will remove all swagger-mcp-server files and configuration. Continue?"):
        click.echo("Uninstallation cancelled")
        return

    # Offer to preserve configuration
    preserve_config = click.confirm("Preserve user configuration files?")

    try:
        uninstaller = UninstallationManager()
        result = await uninstaller.perform_uninstallation(preserve_config)

        click.echo("✅ Uninstallation completed!")

        if result["removed_items"]:
            click.echo("\nRemoved items:")
            for item in result["removed_items"]:
                click.echo(f"   ✓ {item}")

        if result["preserved_items"]:
            click.echo("\nPreserved items:")
            for item in result["preserved_items"]:
                click.echo(f"   📁 {item}")

        if result["warnings"]:
            click.echo("\n⚠️  Warnings:")
            for warning in result["warnings"]:
                click.echo(f"   - {warning}")

    except UninstallationError as e:
        click.echo("❌ Uninstallation encountered issues:")
        for error in e.details.get("errors", []):
            click.echo(f"   - {error}")
```

## Definition of Done
- [ ] Pip-installable package created with proper setuptools configuration and PyPI distribution
- [ ] One-command setup initializes directories, configuration files, and system verification
- [ ] Cross-platform installation support verified on macOS, Linux, and Windows
- [ ] Virtual environment and global installation support with clear setup guidance
- [ ] System compatibility checking validates Python version, dependencies, and platform support
- [ ] Installation verification command validates complete system functionality
- [ ] Clean uninstallation script removes all files and configurations with selective preservation
- [ ] Automated configuration setup with environment detection and sensible defaults
- [ ] Installation documentation with platform-specific instructions and troubleshooting
- [ ] Dependency management with version constraints and conflict resolution
- [ ] Package metadata includes proper classifiers, entry points, and dependency specifications
- [ ] Comprehensive unit tests for installation and setup components (≥80% coverage)
- [ ] Cross-platform integration testing validates installation on all supported systems
- [ ] Package distribution testing ensures proper PyPI publication and installation
- [ ] Setup verification testing confirms all components work after installation
- [ ] Documentation updated with installation guide and troubleshooting procedures

## Validation Criteria
- Single pip install command provides fully functional swagger-mcp-server tool
- Setup process completes successfully on clean systems without manual intervention
- Installation verification confirms all system components work correctly
- Cross-platform installation provides consistent experience across operating systems
- Uninstallation cleanly removes all files while preserving user data when requested
- Package distribution enables easy sharing and deployment in various environments

## Risk Assessment
**Medium-High Risk** - Packaging complexity and cross-platform deployment challenges

**Primary Risks:**
- Python packaging complexity affecting installation reliability across different environments
- Cross-platform compatibility issues with path handling, dependencies, and system integration
- Dependency version conflicts causing installation failures in different Python environments
- Package distribution challenges affecting PyPI publication and version management

**Mitigation Strategies:**
- Use proven Python packaging practices with setuptools and pyproject.toml standards
- Comprehensive cross-platform testing with CI/CD validation on all supported systems
- Conservative dependency version constraints with thorough compatibility testing
- Automated package testing and validation before release and distribution
- Clear documentation and troubleshooting guidance for common installation issues

**Rollback Plan:**
- Provide manual installation instructions if automated package installation fails
- Distribute standalone executables if Python package distribution becomes problematic
- Support local development installation if pip distribution encounters issues
- Provide Docker-based installation alternative if system installation fails

## Story Estimation
**Complexity**: Medium-High
**Effort**: 4 development sessions (14-18 hours)
**Risk Level**: Medium-High
**Dependencies**: 3 (Stories 4.1, 4.4, Epic 1-3 completion)