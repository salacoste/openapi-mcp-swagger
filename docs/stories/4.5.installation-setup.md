# Story 4.5: Installation and Setup Automation

## Story Overview
**Epic**: Epic 4 - CLI Tool & Developer Experience
**Story ID**: 4.5
**Story Type**: Core Feature
**Complexity**: Medium-High
**Sprint**: TBD

## User Story
As a developer,
I want seamless installation and setup with minimal manual configuration,
So that I can start using the tool immediately without complex setup procedures.

## Story Context

### Business Value
- Eliminates installation barriers and reduces time-to-first-success for new users
- Provides automated setup that handles dependencies, configuration, and environment preparation
- Delivers consistent installation experience across different platforms and environments
- Enables rapid adoption by reducing complexity of initial tool setup and configuration

### Dependencies
**Depends On:**
- Story 4.1: Core CLI Framework and Command Structure (CLI framework operational)
- Story 4.4: Configuration Management and Customization (configuration templates and validation)
- All Epic 1, 2, 3 components (complete system functionality for packaging)

**Enables:**
- Story 4.6: Developer Documentation and Examples (installation documentation and guides)
- Complete Epic 4 delivery with production-ready installation and deployment capabilities
- End-to-end user onboarding from installation to functional MCP server

### Technical Context
**Existing System Integration:**
- Integrates with: Python packaging system, configuration management, dependency management
- Technology: Python setuptools/pip, package distribution, system integration, cross-platform deployment
- Follows pattern: Python packaging conventions, automated setup, dependency resolution
- Touch points: Python environment, system dependencies, configuration files, installation validation

## Story Status
**Current Status**: ‚úÖ Story 4.5: Installation and Setup Automation (Ready for Review)

**Completed Components:**
‚úÖ Package distribution setup (setup.py, pyproject.toml, __version__.py)
‚úÖ Installation automation scripts (InstallationManager, SystemCompatibilityChecker, UninstallationManager)
‚úÖ System compatibility checking (Python version, platform, disk space, memory, permissions, dependencies)
‚úÖ Cross-platform installer components (Windows, macOS, Linux support)
‚úÖ Setup validation and health checks (comprehensive verification system)
‚úÖ CLI integration (setup command with full options)
‚úÖ Comprehensive test suite (75 test cases covering all components)
‚úÖ Installation documentation (complete user guide with troubleshooting)

**Implementation Summary:**
- **Package Structure**: Complete Python package with proper entry points and metadata
- **Installation Manager**: Automated setup with directory creation, configuration initialization, and verification
- **Compatibility Checker**: System validation for Python version, platform, resources, and dependencies
- **Uninstaller**: Clean removal with selective preservation options
- **CLI Integration**: Full setup command with force, verify, and uninstall options
- **Testing**: Comprehensive test coverage for all installation components
- **Documentation**: Complete installation guide with troubleshooting and platform-specific instructions

## Acceptance Criteria

### Functional Requirements
1. **Pip-Installable Package Creation**
   - Create proper Python package structure with setuptools configuration and entry points
   - Support pip installation from PyPI with automatic dependency resolution and version management
   - Enable development installation with `pip install -e .` for local development and testing
   - Provide wheel and source distribution packaging for multiple deployment scenarios

2. **One-Command Setup and Initialization**
   - Implement setup command that initializes required directories and configuration files
   - Perform installation verification and system compatibility checking during setup
   - Create default configuration files with appropriate permissions and validation
   - Handle setup errors gracefully with clear guidance for resolution

3. **Cross-Platform Installation Support**
   - Support installation on macOS, Linux, and Windows per NFR6 cross-platform requirements
   - Handle platform-specific dependencies and system integration requirements
   - Provide platform-specific installation instructions and troubleshooting guidance
   - Test installation process on all supported platforms with automated validation

### Integration Requirements
4. **Virtual Environment and Global Installation Support**
   - Support both global system installation and virtual environment deployment
   - Provide clear guidance for virtual environment setup and best practices
   - Handle environment-specific configuration and dependency management
   - Enable isolation between multiple installations and versions

5. **System Dependencies and Compatibility Checking**
   - Verify Python version compatibility (3.9+ requirement) during installation
   - Check for required system libraries and dependencies with installation guidance
   - Provide compatibility checking for different operating system versions
   - Handle dependency conflicts and provide resolution guidance

6. **Automated Configuration and Environment Setup**
   - Initialize configuration directories and files during setup process
   - Create logging directories and configure appropriate permissions
   - Set up database and search index directories with proper structure
   - Generate initial configuration with sensible defaults based on detected environment

### Quality Requirements
7. **Installation Verification and Validation**
   - Provide installation verification command that validates complete system functionality
   - Test all major components and integration points during verification process
   - Generate installation report with system information and configuration validation
   - Support diagnostic mode for troubleshooting installation issues

8. **Clean Uninstallation and Cleanup**
   - Implement uninstallation script that properly cleans up all created files and configurations
   - Remove configuration directories, logs, and temporary files during uninstallation
   - Handle uninstallation conflicts and provide guidance for manual cleanup
   - Preserve user data and configurations with optional backup during uninstallation

9. **Installation Documentation and Guidance**
   - Provide comprehensive installation guide with step-by-step instructions
   - Include troubleshooting section for common installation issues and solutions
   - Create platform-specific installation notes and requirements documentation
   - Support offline installation scenarios with dependency bundling options

## Technical Implementation Notes

### Python Package Structure
```python
# setup.py - Main package configuration
from setuptools import setup, find_packages
import os
import sys

# Ensure Python version compatibility
if sys.version_info < (3, 9):
    sys.exit("Python 3.9 or higher is required")

def read_requirements(filename):
    """Read requirements from file"""
    with open(filename, 'r') as f:
        return [line.strip() for line in f if line.strip() and not line.startswith('#')]

def read_long_description():
    """Read long description from README"""
    with open("README.md", "r", encoding="utf-8") as f:
        return f.read()

setup(
    name="swagger-mcp-server",
    version="1.0.0",
    author="Universal Swagger MCP Server Team",
    author_email="support@swagger-mcp-server.com",
    description="Universal Swagger ‚Üí MCP Server Converter",
    long_description=read_long_description(),
    long_description_content_type="text/markdown",
    url="https://github.com/swagger-mcp-server/swagger-mcp-server",

    packages=find_packages(where="src"),
    package_dir={"": "src"},

    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Topic :: Internet :: WWW/HTTP :: HTTP Servers",
        "Topic :: Documentation",
    ],

    python_requires=">=3.9",

    install_requires=read_requirements("requirements.txt"),

    extras_require={
        "dev": read_requirements("requirements-dev.txt"),
        "test": read_requirements("requirements-test.txt"),
    },

    entry_points={
        "console_scripts": [
            "swagger-mcp-server=swagger_mcp_server.cli:main",
        ],
    },

    include_package_data=True,
    package_data={
        "swagger_mcp_server": [
            "templates/*.yaml",
            "templates/*.json",
            "schemas/*.json",
        ],
    },
)

# pyproject.toml - Modern Python packaging
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools-scm"]
build-backend = "setuptools.build_meta"

[project]
name = "swagger-mcp-server"
dynamic = ["version"]
description = "Universal Swagger ‚Üí MCP Server Converter"
readme = "README.md"
requires-python = ">=3.9"
license = {text = "MIT"}
authors = [
    {name = "Universal Swagger MCP Server Team", email = "support@swagger-mcp-server.com"}
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]
dependencies = [
    "click>=8.0.0",
    "pyyaml>=6.0",
    "aiofiles>=0.8.0",
    "whoosh>=2.7.4",
    "cerberus>=1.3.4",
    "psutil>=5.8.0",
    "aiohttp>=3.8.0",
    "jsonref>=0.2",
    "openapi-spec-validator>=0.4.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "black>=22.0.0",
    "flake8>=5.0.0",
    "mypy>=1.0.0",
]

[project.scripts]
swagger-mcp-server = "swagger_mcp_server.cli:main"

[project.urls]
Homepage = "https://github.com/swagger-mcp-server/swagger-mcp-server"
Documentation = "https://docs.swagger-mcp-server.com"
Repository = "https://github.com/swagger-mcp-server/swagger-mcp-server"
Issues = "https://github.com/swagger-mcp-server/swagger-mcp-server/issues"
```

### Installation and Setup Commands
```python
import click
import os
import sys
import shutil
import platform
from pathlib import Path
from typing import Dict, Any, List
import subprocess
import tempfile

class InstallationManager:
    """Manages installation, setup, and verification processes"""

    def __init__(self):
        self.platform = platform.system().lower()
        self.python_version = sys.version_info
        self.install_dir = Path.home() / ".swagger-mcp-server"

    async def perform_setup(self, force: bool = False) -> Dict[str, Any]:
        """Perform complete system setup"""

        setup_results = {
            "steps_completed": [],
            "warnings": [],
            "errors": []
        }

        try:
            # Step 1: System compatibility check
            await self.check_system_compatibility()
            setup_results["steps_completed"].append("System compatibility verified")

            # Step 2: Create directory structure
            await self.create_directory_structure(force)
            setup_results["steps_completed"].append("Directory structure created")

            # Step 3: Initialize configuration
            await self.initialize_configuration()
            setup_results["steps_completed"].append("Configuration initialized")

            # Step 4: Verify installation
            verification_result = await self.verify_installation()
            setup_results["steps_completed"].append("Installation verified")

            if verification_result.get("warnings"):
                setup_results["warnings"].extend(verification_result["warnings"])

            return setup_results

        except Exception as e:
            setup_results["errors"].append(str(e))
            raise InstallationError(f"Setup failed: {str(e)}", setup_results)

@click.command()
@click.option("--force", "-f", is_flag=True,
              help="Force setup even if already initialized")
@click.option("--verify", "-v", is_flag=True,
              help="Verify installation without setup")
@click.option("--uninstall", is_flag=True,
              help="Uninstall and clean up all files")
@click.pass_context
async def setup(ctx: click.Context, force: bool, verify: bool, uninstall: bool):
    """Setup and installation management

    Initialize the swagger-mcp-server environment, create necessary directories,
    and configure the system for first use. This command handles all setup
    requirements automatically.

    Examples:
      # Initial setup
      swagger-mcp-server setup

      # Force re-setup (overwrites existing configuration)
      swagger-mcp-server setup --force

      # Verify existing installation
      swagger-mcp-server setup --verify

      # Clean uninstall
      swagger-mcp-server setup --uninstall
    """
    try:
        manager = InstallationManager()

        if uninstall:
            await handle_uninstall(manager)
            return

        if verify:
            await handle_verification(manager)
            return

        # Perform setup
        click.echo("üöÄ Starting swagger-mcp-server setup...")

        # Check if already setup
        if manager.is_already_setup() and not force:
            click.echo("‚úÖ System is already set up")
            click.echo("   Use --force to re-initialize or --verify to check installation")
            return

        # Perform setup steps
        result = await manager.perform_setup(force)

        # Display results
        click.echo("\n‚úÖ Setup completed successfully!")
        click.echo("\nCompleted steps:")
        for step in result["steps_completed"]:
            click.echo(f"   ‚úì {step}")

        if result["warnings"]:
            click.echo("\n‚ö†Ô∏è  Warnings:")
            for warning in result["warnings"]:
                click.echo(f"   - {warning}")

        # Next steps guidance
        click.echo("\nüéâ Ready to use swagger-mcp-server!")
        click.echo("Next steps:")
        click.echo("   1. Convert a Swagger file: swagger-mcp-server convert api.json")
        click.echo("   2. Start MCP server: swagger-mcp-server serve")
        click.echo("   3. Check status: swagger-mcp-server status")

    except InstallationError as e:
        handle_installation_error(e, ctx)
    except Exception as e:
        handle_unexpected_error(e, ctx)

async def handle_verification(manager: InstallationManager):
    """Handle installation verification"""

    click.echo("üîç Verifying swagger-mcp-server installation...")

    verification_result = await manager.verify_installation()

    if verification_result["status"] == "success":
        click.echo("‚úÖ Installation verification successful!")

        # Display system information
        click.echo("\nüìã System Information:")
        sys_info = verification_result["system_info"]
        click.echo(f"   Platform: {sys_info['platform']}")
        click.echo(f"   Python: {sys_info['python_version']}")
        click.echo(f"   Installation: {sys_info['install_path']}")

        # Display component status
        click.echo("\nüß© Component Status:")
        components = verification_result["components"]
        for component, status in components.items():
            status_emoji = "‚úÖ" if status["working"] else "‚ùå"
            click.echo(f"   {status_emoji} {component}: {status['message']}")

    else:
        click.echo("‚ùå Installation verification failed!")
        click.echo("\nIssues found:")
        for issue in verification_result.get("issues", []):
            click.echo(f"   - {issue}")

        click.echo("\nTry running: swagger-mcp-server setup --force")
```

### System Compatibility and Dependency Checking
```python
class SystemCompatibilityChecker:
    """Checks system compatibility and dependencies"""

    async def check_system_compatibility(self) -> Dict[str, Any]:
        """Comprehensive system compatibility check"""

        compatibility_report = {
            "compatible": True,
            "issues": [],
            "warnings": [],
            "system_info": {}
        }

        # Python version check
        python_check = self.check_python_version()
        compatibility_report["system_info"]["python"] = python_check
        if not python_check["compatible"]:
            compatibility_report["compatible"] = False
            compatibility_report["issues"].append(python_check["message"])

        # Platform support check
        platform_check = self.check_platform_support()
        compatibility_report["system_info"]["platform"] = platform_check
        if not platform_check["supported"]:
            compatibility_report["compatible"] = False
            compatibility_report["issues"].append(platform_check["message"])

        # Disk space check
        disk_check = self.check_disk_space()
        compatibility_report["system_info"]["disk"] = disk_check
        if not disk_check["sufficient"]:
            compatibility_report["warnings"].append(disk_check["message"])

        # Memory check
        memory_check = self.check_memory()
        compatibility_report["system_info"]["memory"] = memory_check
        if not memory_check["sufficient"]:
            compatibility_report["warnings"].append(memory_check["message"])

        # Network connectivity (optional)
        network_check = await self.check_network_connectivity()
        compatibility_report["system_info"]["network"] = network_check
        if not network_check["available"]:
            compatibility_report["warnings"].append(network_check["message"])

        return compatibility_report

    def check_python_version(self) -> Dict[str, Any]:
        """Check Python version compatibility"""

        min_version = (3, 9)
        current_version = sys.version_info[:2]

        if current_version >= min_version:
            return {
                "compatible": True,
                "current": f"{current_version[0]}.{current_version[1]}",
                "required": f"{min_version[0]}.{min_version[1]}+",
                "message": f"Python {current_version[0]}.{current_version[1]} is supported"
            }
        else:
            return {
                "compatible": False,
                "current": f"{current_version[0]}.{current_version[1]}",
                "required": f"{min_version[0]}.{min_version[1]}+",
                "message": f"Python {min_version[0]}.{min_version[1]}+ required, found {current_version[0]}.{current_version[1]}"
            }

    def check_platform_support(self) -> Dict[str, Any]:
        """Check operating system support"""

        supported_platforms = ["windows", "darwin", "linux"]
        current_platform = platform.system().lower()

        if current_platform in supported_platforms:
            return {
                "supported": True,
                "platform": current_platform,
                "message": f"{platform.system()} is supported"
            }
        else:
            return {
                "supported": False,
                "platform": current_platform,
                "message": f"{platform.system()} is not officially supported"
            }

    def check_disk_space(self, required_mb: int = 100) -> Dict[str, Any]:
        """Check available disk space"""

        try:
            install_path = Path.home()
            disk_usage = shutil.disk_usage(install_path)
            available_mb = disk_usage.free / (1024 * 1024)

            if available_mb >= required_mb:
                return {
                    "sufficient": True,
                    "available_mb": int(available_mb),
                    "required_mb": required_mb,
                    "message": f"{int(available_mb)}MB available (‚â•{required_mb}MB required)"
                }
            else:
                return {
                    "sufficient": False,
                    "available_mb": int(available_mb),
                    "required_mb": required_mb,
                    "message": f"Insufficient disk space: {int(available_mb)}MB available, {required_mb}MB required"
                }

        except Exception:
            return {
                "sufficient": True,  # Assume sufficient if can't check
                "message": "Could not check disk space"
            }
```

### Uninstallation and Cleanup
```python
class UninstallationManager:
    """Handles clean uninstallation and file cleanup"""

    async def perform_uninstallation(self, preserve_config: bool = False) -> Dict[str, Any]:
        """Perform complete system uninstallation"""

        uninstall_results = {
            "removed_items": [],
            "preserved_items": [],
            "warnings": [],
            "errors": []
        }

        try:
            # Remove installation directory
            if self.install_dir.exists():
                if preserve_config:
                    await self.selective_cleanup(uninstall_results)
                else:
                    shutil.rmtree(self.install_dir)
                    uninstall_results["removed_items"].append(str(self.install_dir))

            # Remove package (if installed via pip)
            pip_result = await self.uninstall_pip_package()
            if pip_result["success"]:
                uninstall_results["removed_items"].append("pip package")
            else:
                uninstall_results["warnings"].append(pip_result["message"])

            # Clean up temporary files
            temp_cleanup = await self.cleanup_temp_files()
            uninstall_results["removed_items"].extend(temp_cleanup)

            return uninstall_results

        except Exception as e:
            uninstall_results["errors"].append(str(e))
            raise UninstallationError(f"Uninstallation failed: {str(e)}", uninstall_results)

    async def selective_cleanup(self, results: Dict[str, Any]):
        """Selective cleanup preserving user configuration"""

        # Remove cache directories
        cache_dirs = ["search_index", "__pycache__", ".cache"]
        for cache_dir in cache_dirs:
            cache_path = self.install_dir / cache_dir
            if cache_path.exists():
                shutil.rmtree(cache_path)
                results["removed_items"].append(f"cache: {cache_dir}")

        # Remove log files
        log_files = list(self.install_dir.glob("*.log"))
        for log_file in log_files:
            log_file.unlink()
            results["removed_items"].append(f"log: {log_file.name}")

        # Preserve configuration files
        config_files = ["config.yaml", "servers.json"]
        for config_file in config_files:
            config_path = self.install_dir / config_file
            if config_path.exists():
                results["preserved_items"].append(f"config: {config_file}")

async def handle_uninstall(manager: InstallationManager):
    """Handle uninstallation process"""

    click.echo("üóëÔ∏è  Starting swagger-mcp-server uninstallation...")

    # Confirm uninstallation
    if not click.confirm("This will remove all swagger-mcp-server files and configuration. Continue?"):
        click.echo("Uninstallation cancelled")
        return

    # Offer to preserve configuration
    preserve_config = click.confirm("Preserve user configuration files?")

    try:
        uninstaller = UninstallationManager()
        result = await uninstaller.perform_uninstallation(preserve_config)

        click.echo("‚úÖ Uninstallation completed!")

        if result["removed_items"]:
            click.echo("\nRemoved items:")
            for item in result["removed_items"]:
                click.echo(f"   ‚úì {item}")

        if result["preserved_items"]:
            click.echo("\nPreserved items:")
            for item in result["preserved_items"]:
                click.echo(f"   üìÅ {item}")

        if result["warnings"]:
            click.echo("\n‚ö†Ô∏è  Warnings:")
            for warning in result["warnings"]:
                click.echo(f"   - {warning}")

    except UninstallationError as e:
        click.echo("‚ùå Uninstallation encountered issues:")
        for error in e.details.get("errors", []):
            click.echo(f"   - {error}")
```

## Definition of Done
- [ ] Pip-installable package created with proper setuptools configuration and PyPI distribution
- [ ] One-command setup initializes directories, configuration files, and system verification
- [ ] Cross-platform installation support verified on macOS, Linux, and Windows
- [ ] Virtual environment and global installation support with clear setup guidance
- [ ] System compatibility checking validates Python version, dependencies, and platform support
- [ ] Installation verification command validates complete system functionality
- [ ] Clean uninstallation script removes all files and configurations with selective preservation
- [ ] Automated configuration setup with environment detection and sensible defaults
- [ ] Installation documentation with platform-specific instructions and troubleshooting
- [ ] Dependency management with version constraints and conflict resolution
- [ ] Package metadata includes proper classifiers, entry points, and dependency specifications
- [ ] Comprehensive unit tests for installation and setup components (‚â•80% coverage)
- [ ] Cross-platform integration testing validates installation on all supported systems
- [ ] Package distribution testing ensures proper PyPI publication and installation
- [ ] Setup verification testing confirms all components work after installation
- [ ] Documentation updated with installation guide and troubleshooting procedures

## Validation Criteria
- Single pip install command provides fully functional swagger-mcp-server tool
- Setup process completes successfully on clean systems without manual intervention
- Installation verification confirms all system components work correctly
- Cross-platform installation provides consistent experience across operating systems
- Uninstallation cleanly removes all files while preserving user data when requested
- Package distribution enables easy sharing and deployment in various environments

## Risk Assessment
**Medium-High Risk** - Packaging complexity and cross-platform deployment challenges

**Primary Risks:**
- Python packaging complexity affecting installation reliability across different environments
- Cross-platform compatibility issues with path handling, dependencies, and system integration
- Dependency version conflicts causing installation failures in different Python environments
- Package distribution challenges affecting PyPI publication and version management

**Mitigation Strategies:**
- Use proven Python packaging practices with setuptools and pyproject.toml standards
- Comprehensive cross-platform testing with CI/CD validation on all supported systems
- Conservative dependency version constraints with thorough compatibility testing
- Automated package testing and validation before release and distribution
- Clear documentation and troubleshooting guidance for common installation issues

**Rollback Plan:**
- Provide manual installation instructions if automated package installation fails
- Distribute standalone executables if Python package distribution becomes problematic
- Support local development installation if pip distribution encounters issues
- Provide Docker-based installation alternative if system installation fails

## Story Estimation
**Complexity**: Medium-High
**Effort**: 4 development sessions (14-18 hours)
**Risk Level**: Medium-High
**Dependencies**: 3 (Stories 4.1, 4.4, Epic 1-3 completion)