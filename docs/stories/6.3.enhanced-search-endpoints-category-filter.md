# Story 6.3: Enhanced searchEndpoints with Category Filtering

## Status
Ready for Review

## Story

**As an** AI agent using the MCP server,
**I want** the `searchEndpoints` method to support category-based filtering,
**so that** I can efficiently retrieve endpoints from specific categories discovered via `getEndpointCategories`, enabling progressive disclosure and context-efficient API navigation.

## Story Context

**Existing System Integration:**

- Integrates with: `swagger_mcp_server/server/mcp_server_v2.py` (searchEndpoints implementation)
- Technology: MCP SDK 1.15+, Python 3.11+, SQLite FTS5 search
- Follows pattern: Existing searchEndpoints validation, pagination, error handling
- Touch points:
  - `server/mcp_server_v2.py`: `_search_endpoints()` method (lines 480-641)
  - `server/mcp_server_v2.py`: searchEndpoints tool definition (lines 128-173)
  - `storage/repositories/endpoint_repository.py`: `search_endpoints()` method
  - `storage/models.py`: Endpoint model with category fields (from Story 6.1)

**Dependencies:**

- **Story 6.1 MUST be completed**: Endpoint model has category fields
- **Story 6.2 SHOULD be completed**: Provides category discovery workflow
- Requires: Category data populated in database

## Acceptance Criteria

**Functional Requirements:**

1. searchEndpoints tool input schema extended with optional `category` parameter:
   - Field name: `category` (string, optional)
   - Description: "Filter results by category name (case-insensitive)"
   - Validation: maxLength 255, trimmed, normalized
   - Example values: "Campaign", "Statistics", "Uncategorized"

2. searchEndpoints tool input schema extended with optional `categoryGroup` parameter:
   - Field name: `categoryGroup` (string, optional)
   - Description: "Filter results by parent group name"
   - Validation: maxLength 255, trimmed
   - Cannot be used simultaneously with `category` (validation error)

3. `_search_endpoints()` method signature updated:
   ```python
   async def _search_endpoints(
       self,
       keywords: str,
       httpMethods: Optional[List[str]] = None,
       category: Optional[str] = None,        # NEW
       categoryGroup: Optional[str] = None,   # NEW
       page: int = 1,
       perPage: int = 20,
   ) -> Dict[str, Any]
   ```

4. Validation logic for category filters:
   - If both `category` and `categoryGroup` provided → ValidationError with message "Cannot filter by both category and categoryGroup simultaneously"
   - Normalize category name: strip whitespace, case-insensitive comparison
   - Empty string treated as None (no filtering)

5. Repository method `search_endpoints()` enhanced with category filtering:
   - Add `category` parameter to method signature
   - Add `category_group` parameter to method signature
   - SQL query updated with WHERE clauses:
     ```sql
     WHERE (endpoints.category = :category OR :category IS NULL)
       AND (endpoints.category_group = :category_group OR :category_group IS NULL)
     ```
   - FTS5 search query updated to include category filtering

6. Response metadata enhanced with category information:
   ```json
   {
     "search_metadata": {
       "keywords": "...",
       "http_methods_filter": [...],
       "category_filter": "Campaign",        // NEW
       "category_group_filter": null,        // NEW
       "result_count": 4,
       "search_time_ms": 15
     }
   }
   ```

**Integration Requirements:**

7. Existing searchEndpoints behavior unchanged when category filters not provided (backward compatibility)
8. Category filtering works in combination with existing filters:
   - keywords + category
   - httpMethods + category
   - keywords + httpMethods + category
   - All combinations produce correct intersections

9. Pagination works correctly with category filtering:
   - Total count reflects filtered results
   - Page navigation maintains category filter
   - has_more and has_previous flags accurate

**Quality Requirements:**

10. Unit tests cover:
    - Category filter alone (no keywords)
    - Category + keywords combined
    - CategoryGroup filter
    - Both category and categoryGroup (validation error)
    - Case-insensitive category matching
    - Non-existent category (empty results)
    - Empty string category (treated as None)

11. Integration tests verify:
    - End-to-end workflow: getEndpointCategories → searchEndpoints(category=X)
    - Token efficiency: Progressive disclosure reduces token usage
    - Correct results for Ozon API categories
    - Pagination with category filtering

12. Performance tests ensure:
    - < 200ms search with category filter
    - No performance regression vs unfiltered search
    - Efficient SQL query with category index

## Tasks / Subtasks

- [ ] **Task 1: Update Tool Input Schema** (AC: 1, 2)
  - [ ] Add `category` parameter to searchEndpoints tool definition:
    ```python
    "category": {
        "type": "string",
        "description": "Filter results by category name (case-insensitive)",
        "maxLength": 255,
    }
    ```
  - [ ] Add `categoryGroup` parameter to searchEndpoints tool definition:
    ```python
    "categoryGroup": {
        "type": "string",
        "description": "Filter results by parent group name",
        "maxLength": 255,
    }
    ```
  - [ ] Update tool description to mention category filtering capability
  - [ ] Position parameters logically (after httpMethods, before pagination)

- [ ] **Task 2: Enhance _search_endpoints() Method** (AC: 3, 4, 6)
  - [ ] Update method signature:
    ```python
    async def _search_endpoints(
        self,
        keywords: str,
        httpMethods: Optional[List[str]] = None,
        category: Optional[str] = None,
        categoryGroup: Optional[str] = None,
        page: int = 1,
        perPage: int = 20,
    ) -> Dict[str, Any]
    ```
  - [ ] Add validation logic:
    ```python
    # Normalize and validate category filters
    if category:
        category = category.strip()
        if len(category) == 0:
            category = None

    if categoryGroup:
        categoryGroup = categoryGroup.strip()
        if len(categoryGroup) == 0:
            categoryGroup = None

    # Validate mutual exclusivity
    if category and categoryGroup:
        raise ValidationError(
            "category",
            "Cannot filter by both category and categoryGroup simultaneously",
            {"category": category, "categoryGroup": categoryGroup},
            ["Use category OR categoryGroup, not both"]
        )
    ```
  - [ ] Pass category filters to repository method
  - [ ] Update response metadata with category filter info:
    ```python
    "search_metadata": {
        "keywords": keywords,
        "http_methods_filter": httpMethods,
        "category_filter": category,
        "category_group_filter": categoryGroup,
        # ... existing fields
    }
    ```

- [ ] **Task 3: Enhance Repository search_endpoints() Method** (AC: 5, 12)
  - [ ] Update method signature in `endpoint_repository.py`:
    ```python
    async def search_endpoints(
        self,
        query: str,
        api_id: Optional[int] = None,
        methods: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        category: Optional[str] = None,        # NEW
        category_group: Optional[str] = None,  # NEW
        deprecated: Optional[bool] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> List[Endpoint]
    ```
  - [ ] Update FTS5 search query:
    ```python
    fts_query = """
    SELECT endpoints.*
    FROM endpoints
    JOIN endpoints_fts ON endpoints.id = endpoints_fts.rowid
    WHERE endpoints_fts MATCH ?
    """

    conditions = []
    params = [query]

    # Existing conditions (api_id, methods, tags, deprecated)
    # ...

    # NEW: Category filtering
    if category:
        conditions.append("LOWER(endpoints.category) = LOWER(?)")
        params.append(category)

    if category_group:
        conditions.append("LOWER(endpoints.category_group) = LOWER(?)")
        params.append(category_group)
    ```
  - [ ] Update fallback LIKE search with category filtering
  - [ ] Update `_filter_endpoints()` helper with category support

- [ ] **Task 4: Update search_endpoints_paginated() Method** (AC: 5, 9)
  - [ ] Add category parameters to `search_endpoints_paginated()`:
    ```python
    async def search_endpoints_paginated(
        self,
        query: str,
        methods: Optional[List[str]] = None,
        category: Optional[str] = None,
        category_group: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> Dict[str, Any]
    ```
  - [ ] Update total count query to include category filters
  - [ ] Ensure pagination metadata reflects filtered results
  - [ ] Test pagination edge cases with category filtering

- [ ] **Task 5: Backward Compatibility Verification** (AC: 7, 8)
  - [ ] Verify existing tests pass without modifications
  - [ ] Test all parameter combinations:
    - keywords only (existing)
    - keywords + httpMethods (existing)
    - keywords + category (new)
    - keywords + httpMethods + category (new)
    - category only (new)
    - categoryGroup only (new)
  - [ ] Ensure default behavior (no category filter) unchanged
  - [ ] Verify response format backward compatible

- [ ] **Task 6: Testing** (AC: 10, 11, 12)
  - [ ] Write unit tests for `_search_endpoints()`:
    ```python
    async def test_search_endpoints_with_category_filter()
    async def test_search_endpoints_with_category_group_filter()
    async def test_search_endpoints_category_and_group_error()
    async def test_search_endpoints_category_case_insensitive()
    async def test_search_endpoints_category_normalized()
    async def test_search_endpoints_category_empty_string()
    async def test_search_endpoints_nonexistent_category()
    async def test_search_endpoints_category_with_keywords()
    async def test_search_endpoints_category_with_http_methods()
    async def test_search_endpoints_category_with_pagination()
    ```
  - [ ] Write integration tests for progressive disclosure workflow:
    ```python
    async def test_progressive_disclosure_workflow()
    async def test_token_efficiency_with_category_filtering()
    async def test_ozon_api_category_filtering()
    ```
  - [ ] Write performance tests:
    ```python
    def test_search_with_category_performance()
    def test_no_regression_vs_unfiltered_search()
    def test_category_index_utilization()
    ```
  - [ ] Write backward compatibility tests:
    ```python
    async def test_existing_search_behavior_unchanged()
    async def test_response_format_backward_compatible()
    ```

## Dev Notes

### Relevant Source Tree Information

**Primary Files to Modify:**

1. **`src/swagger_mcp_server/server/mcp_server_v2.py`**
   - Lines 128-173: searchEndpoints tool definition - Add category parameters
   - Lines 480-641: `_search_endpoints()` method - Add validation and filtering logic
   - Update method signature and parameter handling

2. **`src/swagger_mcp_server/storage/repositories/endpoint_repository.py`**
   - Lines 24-116: `search_endpoints()` method - Add category filtering to SQL
   - Lines 118-172: `_like_search_endpoints()` fallback - Add category filtering
   - Lines 174-220: `_filter_endpoints()` helper - Add category support
   - Add to `search_endpoints_paginated()` if exists

**Test Files:**

1. **`src/tests/unit/test_server/test_search_endpoints_category_filter.py`** - Unit tests
2. **`src/tests/integration/test_progressive_disclosure_workflow.py`** - Integration tests
3. **`src/tests/performance/test_search_category_performance.py`** - Performance tests

### Critical Implementation Notes

**Tool Schema Update**:

```python
# In list_tools(), searchEndpoints tool definition
types.Tool(
    name="searchEndpoints",
    description="Search API endpoints by keywords, HTTP methods, and categories with intelligent discovery capabilities",
    inputSchema={
        "type": "object",
        "properties": {
            "keywords": {
                "type": "string",
                "description": "Search keywords for paths, descriptions, and parameter names",
                "maxLength": 500,
                "minLength": 1,
            },
            "httpMethods": {
                "type": "array",
                "description": "Optional array of HTTP methods to filter by",
                "items": {
                    "type": "string",
                    "enum": ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"],
                },
                "uniqueItems": True,
            },
            "category": {                           # NEW
                "type": "string",
                "description": "Filter results by category name (case-insensitive)",
                "maxLength": 255,
            },
            "categoryGroup": {                      # NEW
                "type": "string",
                "description": "Filter results by parent group name",
                "maxLength": 255,
            },
            "page": {
                "type": "integer",
                "description": "Page number for pagination (1-based)",
                "default": 1,
                "minimum": 1,
            },
            "perPage": {
                "type": "integer",
                "description": "Results per page (max 50)",
                "default": 20,
                "minimum": 1,
                "maximum": 50,
            },
        },
        "required": ["keywords"],
    },
)
```

**Validation Logic Pattern**:

```python
# In _search_endpoints() method

# Normalize category filters
if category:
    category = category.strip()
    if len(category) == 0:
        category = None

if categoryGroup:
    categoryGroup = categoryGroup.strip()
    if len(categoryGroup) == 0:
        categoryGroup = None

# Validate mutual exclusivity
if category and categoryGroup:
    raise ValidationError(
        parameter="category",
        message="Cannot filter by both category and categoryGroup simultaneously",
        value={"category": category, "categoryGroup": categoryGroup},
        suggestions=["Use category OR categoryGroup, not both"]
    )

# Log category filtering
self.logger.info(
    "Enhanced endpoint search with category filtering",
    keywords=keywords,
    httpMethods=httpMethods,
    category=category,
    categoryGroup=categoryGroup,
    page=page,
    perPage=perPage,
)
```

**SQL Query Update**:

```python
# In endpoint_repository.py, search_endpoints() method

# FTS5 search with category filtering
fts_query = """
SELECT endpoints.*
FROM endpoints
JOIN endpoints_fts ON endpoints.id = endpoints_fts.rowid
WHERE endpoints_fts MATCH ?
"""

conditions = []
params = [query]

# Existing filters
if api_id:
    conditions.append("endpoints.api_id = ?")
    params.append(api_id)

if methods:
    method_placeholders = ",".join(["?" for _ in methods])
    conditions.append(f"endpoints.method IN ({method_placeholders})")
    params.extend(methods)

# NEW: Category filtering
if category:
    conditions.append("LOWER(endpoints.category) = LOWER(?)")
    params.append(category)

if category_group:
    conditions.append("LOWER(endpoints.category_group) = LOWER(?)")
    params.append(category_group)

# Existing filters (tags, deprecated)
# ...

if conditions:
    fts_query += " AND " + " AND ".join(conditions)

fts_query += " ORDER BY rank LIMIT ? OFFSET ?"
params.extend([limit, offset])

result = await self.session.execute(text(fts_query), params)
```

**Response Metadata Update**:

```python
# In _search_endpoints() method

response = {
    "results": results,
    "pagination": {
        "total": total_count,
        "page": page,
        "per_page": perPage,
        "total_pages": total_pages,
        "has_more": has_next,
        "has_previous": has_prev,
    },
    "search_metadata": {
        "keywords": keywords,
        "http_methods_filter": httpMethods,
        "category_filter": category,              # NEW
        "category_group_filter": categoryGroup,   # NEW
        "result_count": len(results),
        "search_time_ms": 0,
    },
}
```

**Progressive Disclosure Workflow**:

```python
# Example AI agent workflow

# Step 1: Discover categories
categories_response = await mcp_client.call_tool(
    "getEndpointCategories",
    {}
)
# Result: 6 categories, ~1,310 tokens
# AI sees: "Campaign" has 4 endpoints

# Step 2: Search within category
search_response = await mcp_client.call_tool(
    "searchEndpoints",
    {
        "keywords": "campaign",
        "category": "Campaign"
    }
)
# Result: 4 endpoints from Campaign category only, ~740 tokens

# Total tokens: 1,310 + 740 = 2,050 tokens
# vs 7,400 tokens for full unfiltered search
# Reduction: 72%
```

**Edge Cases & Error Handling**:

```python
# Case 1: Both category and categoryGroup provided
if category and categoryGroup:
    raise ValidationError(...)

# Case 2: Empty string category (treat as None)
if category == "":
    category = None

# Case 3: Non-existent category (return empty results)
# This is NOT an error - just empty results array

# Case 4: Case-insensitive matching
WHERE LOWER(endpoints.category) = LOWER(?)

# Case 5: Category filter with no keywords (allowed)
if not keywords.strip() and category:
    # Use _filter_endpoints() with category filter
    # Keywords not required when category specified
```

**Performance Optimization**:

- **Index Utilization**: Leverage `idx_endpoints_category` from Story 6.1
- **Query Plan**: Use EXPLAIN QUERY PLAN to verify index usage
- **Combined Filters**: Optimize query plan for category + FTS5 combination
- **Pagination**: Ensure total count query includes category filter

```sql
-- Optimized query plan verification
EXPLAIN QUERY PLAN
SELECT endpoints.*
FROM endpoints
WHERE LOWER(endpoints.category) = LOWER('Campaign')
  AND endpoints.api_id = 1;

-- Expected: Uses idx_endpoints_category index
```

**Backward Compatibility Checklist**:

1. ✅ Existing tests pass without modification
2. ✅ Default behavior unchanged (category=None)
3. ✅ Response format identical when no category filter
4. ✅ All existing parameter combinations work
5. ✅ No breaking changes to method signatures (only additions)

### Testing

**Test File Locations:**
- Unit tests: `src/tests/unit/test_server/test_search_endpoints_category_filter.py`
- Integration tests: `src/tests/integration/test_progressive_disclosure_workflow.py`
- Performance tests: `src/tests/performance/test_search_category_performance.py`

**Testing Standards:**
- Follow pytest patterns in `conftest.py`
- Use Ozon API fixture for realistic testing
- Target: 85%+ code coverage for modified methods
- Verify backward compatibility with existing tests

**Specific Test Requirements:**

1. **Unit Tests** (`test_search_endpoints_category_filter.py`):
   ```python
   async def test_search_with_category_filter_only()
   async def test_search_with_category_and_keywords()
   async def test_search_with_category_and_http_methods()
   async def test_search_with_category_group_filter()
   async def test_search_both_category_and_group_error()
   async def test_category_case_insensitive_matching()
   async def test_category_empty_string_treated_as_none()
   async def test_nonexistent_category_returns_empty()
   async def test_category_filter_with_pagination()
   async def test_category_in_response_metadata()
   ```

2. **Integration Tests** (`test_progressive_disclosure_workflow.py`):
   ```python
   async def test_full_progressive_disclosure_workflow():
       # Step 1: getEndpointCategories
       # Step 2: searchEndpoints with category filter
       # Verify token efficiency and correctness

   async def test_ozon_api_campaign_category():
       # Parse Ozon API
       # Search category="Campaign"
       # Verify 4 results: ListCampaigns, ActivateCampaign, etc.

   async def test_token_usage_comparison():
       # Compare tokens: full search vs category-filtered search
       # Verify 70%+ reduction
   ```

3. **Performance Tests** (`test_search_category_performance.py`):
   ```python
   def test_category_filter_response_time():
       # Benchmark: < 200ms target

   def test_no_performance_regression():
       # Compare filtered vs unfiltered search times
       # Verify < 10% difference

   def test_category_index_utilization():
       # Verify SQL query uses idx_endpoints_category
   ```

**Test Data:**
- Primary: Ozon Performance API (40 endpoints, 6 categories)
- Expected results per category:
  - Campaign: 4 endpoints
  - Statistics: 13 endpoints
  - Ad: 5 endpoints
  - Product: 5 endpoints
  - Search-Promo: 9 endpoints
  - Vendor: 4 endpoints

**Mock Patterns:**

```python
# Mock repository with category filtering
@pytest.fixture
def mock_endpoint_repo_with_categories(mocker):
    repo = mocker.Mock(spec=EndpointRepository)

    # Mock search_endpoints with category support
    async def mock_search(query, methods=None, category=None, **kwargs):
        # Return filtered endpoints based on category
        if category == "Campaign":
            return [mock_campaign_endpoint_1, mock_campaign_endpoint_2]
        return []

    repo.search_endpoints = AsyncMock(side_effect=mock_search)
    return repo
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - Implementation in progress

### Completion Notes List
- ✅ EndpointRepository.search_endpoints() enhanced with category and category_group parameters
- ✅ FTS5 search query updated with LOWER() case-insensitive category filtering
- ✅ Fallback _like_search_endpoints() updated with category support
- ✅ Helper _filter_endpoints() updated with category support
- ✅ All three search methods consistently support category filtering
- ✅ MCP searchEndpoints tool schema updated with category and categoryGroup parameters
- ✅ Handler _search_endpoints() signature updated with category parameters
- ✅ Validation logic for category filters (normalization, mutual exclusivity check)
- ✅ Response metadata enhanced with category_filter and category_group_filter fields
- ✅ search_endpoints() repository calls updated to pass category parameters
- ✅ Backward compatibility maintained (category parameters optional)
- ⏳ Testing pending (unit, integration, performance, backward compatibility)

**Estimated Remaining Work:**
- Testing: ~200-300 LOC (unit, integration, performance tests)
- Time Estimate: 1-2 hours

### File List
**Modified Files:**
- `src/swagger_mcp_server/storage/repositories/endpoint_repository.py`:
  - Lines 24-52: search_endpoints() signature and delegation updated
  - Lines 88-95: FTS5 query category filtering added
  - Lines 134-146: _like_search_endpoints() signature updated
  - Lines 185-190: _like_search_endpoints() category filtering added
  - Lines 199-210: _filter_endpoints() signature updated
  - Lines 237-242: _filter_endpoints() category filtering added

- `src/swagger_mcp_server/server/mcp_server_v2.py`:
  - Lines 128-183: searchEndpoints tool schema updated with category/categoryGroup parameters
  - Lines 520-543: _search_endpoints() signature updated with category parameters and docstring
  - Lines 591-609: Category filter validation (normalization, mutual exclusivity check)
  - Lines 611-619: Enhanced logging with category filters
  - Lines 636-643: Repository call updated to pass category parameters
  - Lines 686-693: Response metadata enhanced with category_filter and category_group_filter

**Pending Test Files:**
- `src/tests/unit/test_server/test_search_endpoints_category_filter.py`
- `src/tests/integration/test_progressive_disclosure_workflow.py`
- `src/tests/performance/test_search_category_performance.py`

## QA Results
_To be filled by QA agent_