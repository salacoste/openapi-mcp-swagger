# Story 4.4: Configuration Management and Customization

## Story Overview
**Epic**: Epic 4 - CLI Tool & Developer Experience
**Story ID**: 4.4
**Story Type**: Core Feature
**Complexity**: Medium
**Sprint**: TBD
**Status**: Ready for Review

## User Story
As a developer,
I want flexible configuration options for customizing server behavior and performance,
So that I can optimize the system for my specific use cases and environments.

## Story Context

### Business Value
- Enables customization of MCP server behavior for different environments and use cases
- Provides operational flexibility for development, staging, and production deployments
- Delivers configuration management that scales from simple setup to enterprise deployment
- Supports performance tuning and optimization for specific API documentation characteristics

### Dependencies
**Depends On:**
- Story 4.1: Core CLI Framework and Command Structure (CLI framework with configuration support)
- Story 4.2: Swagger to MCP Server Conversion Command (server generation creating configurations)
- Story 4.3: MCP Server Management and Control (server instances requiring configuration)

**Enables:**
- Story 4.5: Installation and Setup Automation (configuration templates and defaults)
- Complete CLI tool functionality with comprehensive customization capabilities
- Production-ready deployments with environment-specific configurations

### Technical Context
**Existing System Integration:**
- Integrates with: CLI framework, MCP server instances, search engine settings, database configuration
- Technology: Python with YAML/JSON configuration, validation schemas, template generation
- Follows pattern: Configuration management patterns, validation systems, environment handling
- Touch points: Configuration files, environment variables, server settings, search parameters

## Acceptance Criteria

### Functional Requirements
1. **Configuration Command Implementation**
   - Implement `config` command for managing global and server-specific settings
   - Support configuration actions: show (display current config), set (modify values), reset (restore defaults)
   - Enable nested configuration management using dot notation (e.g., `server.port`, `search.index_size`)
   - Provide configuration validation with clear error messages for invalid settings

2. **Configuration File Generation and Management**
   - Support configuration file generation with sensible defaults and comprehensive documentation
   - Create template configurations for common deployment scenarios (development, staging, production)
   - Enable configuration file validation and syntax checking before application
   - Support multiple configuration file formats: YAML (primary), JSON (secondary)

3. **Environment Variable Override System**
   - Implement environment variable overrides for deployment automation and container environments
   - Support systematic environment variable mapping with clear naming conventions
   - Enable environment-specific configuration without modifying configuration files
   - Provide environment variable discovery and validation for operational deployments

### Integration Requirements
4. **Server Configuration Customization**
   - Enable customization of MCP server parameters: host, port, connection limits, timeouts
   - Support database configuration: connection settings, performance tuning, backup options
   - Provide logging configuration: levels, formats, output destinations, rotation policies
   - Enable SSL/TLS configuration for secure deployments and authentication settings

5. **Search Engine Configuration**
   - Support search parameter customization: field weights, ranking algorithms, cache settings
   - Enable indexing configuration: batch sizes, optimization thresholds, update frequencies
   - Provide performance tuning options: memory limits, concurrent operations, timeout settings
   - Support search result customization: page sizes, filtering options, result formats

6. **Deployment Environment Templates**
   - Provide configuration templates optimized for different deployment scenarios
   - Create development templates with debugging enabled and relaxed security settings
   - Generate production templates with security hardening and performance optimization
   - Support container and cloud deployment configuration with environment-specific defaults

### Quality Requirements
7. **Configuration Validation and Safety**
   - Comprehensive validation prevents invalid configurations from causing system failures
   - Configuration changes require confirmation for critical settings affecting system stability
   - Backup and restore capabilities for configuration changes with rollback functionality
   - Configuration migration support for version upgrades and schema changes

8. **User Experience and Documentation**
   - Configuration options are well-documented with descriptions, examples, and valid ranges
   - Configuration help system provides contextual guidance for complex settings
   - Configuration discovery enables users to understand available options and their impacts
   - Error messages provide specific guidance for fixing invalid configuration values

9. **Performance and Operational Impact**
   - Configuration loading and validation complete quickly without impacting system startup
   - Configuration changes can be applied without full system restart where possible
   - Configuration monitoring enables tracking of settings impact on system performance
   - Configuration audit trail maintains history of changes for troubleshooting and compliance

## Technical Implementation Notes

### Configuration Management Architecture
```python
import click
import yaml
import json
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
import os
from dataclasses import dataclass
from cerberus import Validator

@dataclass
class ConfigurationSchema:
    """Configuration schema definition and validation"""

    SCHEMA = {
        "server": {
            "type": "dict",
            "schema": {
                "host": {"type": "string", "default": "localhost"},
                "port": {"type": "integer", "min": 1024, "max": 65535, "default": 8080},
                "max_connections": {"type": "integer", "min": 1, "max": 1000, "default": 100},
                "timeout": {"type": "integer", "min": 1, "max": 300, "default": 30},
                "ssl": {
                    "type": "dict",
                    "schema": {
                        "enabled": {"type": "boolean", "default": False},
                        "cert_file": {"type": "string", "nullable": True},
                        "key_file": {"type": "string", "nullable": True}
                    }
                }
            }
        },
        "database": {
            "type": "dict",
            "schema": {
                "path": {"type": "string", "default": "./mcp_server.db"},
                "pool_size": {"type": "integer", "min": 1, "max": 50, "default": 5},
                "timeout": {"type": "integer", "min": 1, "max": 60, "default": 10},
                "backup": {
                    "type": "dict",
                    "schema": {
                        "enabled": {"type": "boolean", "default": True},
                        "interval": {"type": "integer", "min": 3600, "default": 86400},
                        "retention": {"type": "integer", "min": 1, "default": 7}
                    }
                }
            }
        },
        "search": {
            "type": "dict",
            "schema": {
                "engine": {"type": "string", "allowed": ["whoosh"], "default": "whoosh"},
                "index_directory": {"type": "string", "default": "./search_index"},
                "field_weights": {
                    "type": "dict",
                    "schema": {
                        "endpoint_path": {"type": "float", "min": 0.1, "max": 3.0, "default": 1.5},
                        "description": {"type": "float", "min": 0.1, "max": 3.0, "default": 1.0},
                        "parameters": {"type": "float", "min": 0.1, "max": 3.0, "default": 0.8}
                    }
                },
                "performance": {
                    "type": "dict",
                    "schema": {
                        "cache_size_mb": {"type": "integer", "min": 16, "max": 1024, "default": 64},
                        "max_results": {"type": "integer", "min": 10, "max": 10000, "default": 1000}
                    }
                }
            }
        },
        "logging": {
            "type": "dict",
            "schema": {
                "level": {"type": "string", "allowed": ["DEBUG", "INFO", "WARNING", "ERROR"], "default": "INFO"},
                "format": {"type": "string", "default": "%(asctime)s - %(name)s - %(levelname)s - %(message)s"},
                "file": {"type": "string", "nullable": True, "default": None},
                "rotation": {
                    "type": "dict",
                    "schema": {
                        "enabled": {"type": "boolean", "default": False},
                        "max_size_mb": {"type": "integer", "min": 1, "max": 1000, "default": 10},
                        "backup_count": {"type": "integer", "min": 1, "max": 10, "default": 5}
                    }
                }
            }
        }
    }

class ConfigurationManager:
    """Manages system configuration with validation and templates"""

    def __init__(self):
        self.config_dir = Path.home() / ".swagger-mcp-server"
        self.config_file = self.config_dir / "config.yaml"
        self.schema = ConfigurationSchema.SCHEMA
        self.validator = Validator(self.schema)
        self.config_dir.mkdir(exist_ok=True)

    async def load_configuration(self, config_file: Optional[str] = None) -> Dict[str, Any]:
        """Load configuration from file with environment overrides"""

        # Load base configuration
        base_config = self.get_default_configuration()

        # Load from file if exists
        file_path = Path(config_file) if config_file else self.config_file
        if file_path.exists():
            file_config = self.load_config_file(file_path)
            base_config = self.merge_configurations(base_config, file_config)

        # Apply environment variable overrides
        env_config = self.extract_environment_config()
        final_config = self.merge_configurations(base_config, env_config)

        # Validate final configuration
        if not self.validator.validate(final_config):
            raise ConfigurationError("Invalid configuration", self.validator.errors)

        return final_config

@click.command()
@click.argument("action", type=click.Choice(["show", "set", "reset", "init", "validate"]))
@click.argument("key", required=False)
@click.argument("value", required=False)
@click.option("--config", "-c", type=click.Path(),
              help="Configuration file path")
@click.option("--template", "-t", type=click.Choice(["development", "staging", "production"]),
              help="Configuration template for init action")
@click.option("--format", "-f", type=click.Choice(["yaml", "json"]), default="yaml",
              help="Output format")
@click.pass_context
async def config(ctx: click.Context, action: str, key: Optional[str],
                value: Optional[str], config: Optional[str],
                template: Optional[str], format: str):
    """Manage configuration settings

    Show, set, reset, or initialize configuration options for the MCP server converter.
    Configuration supports nested keys using dot notation (e.g., server.port).

    Actions:
      show     - Display current configuration or specific key
      set      - Set configuration value for specified key
      reset    - Reset configuration to defaults
      init     - Initialize configuration file with template
      validate - Validate configuration file syntax and values

    Examples:
      # Show all configuration
      swagger-mcp-server config show

      # Show specific setting
      swagger-mcp-server config show server.port

      # Set server port
      swagger-mcp-server config set server.port 9000

      # Initialize production configuration
      swagger-mcp-server config init --template production

      # Validate configuration file
      swagger-mcp-server config validate --config ./my-config.yaml
    """
    try:
        manager = ConfigurationManager()

        if action == "show":
            await handle_config_show(manager, key, config, format)

        elif action == "set":
            if not key or value is None:
                raise click.UsageError("Both key and value are required for set action")
            await handle_config_set(manager, key, value, config)

        elif action == "reset":
            await handle_config_reset(manager, config, key)

        elif action == "init":
            await handle_config_init(manager, template or "development", config, format)

        elif action == "validate":
            await handle_config_validate(manager, config)

    except ConfigurationError as e:
        handle_config_error(e, ctx)
    except Exception as e:
        handle_unexpected_error(e, ctx)
```

### Configuration Templates System
```python
class ConfigurationTemplateManager:
    """Manages configuration templates for different deployment scenarios"""

    def get_development_template(self) -> Dict[str, Any]:
        """Development environment template with debugging and relaxed settings"""
        return {
            "server": {
                "host": "localhost",
                "port": 8080,
                "max_connections": 10,
                "timeout": 60,
                "ssl": {"enabled": False}
            },
            "database": {
                "path": "./dev_mcp_server.db",
                "pool_size": 2,
                "timeout": 30,
                "backup": {"enabled": False}
            },
            "search": {
                "engine": "whoosh",
                "index_directory": "./dev_search_index",
                "field_weights": {
                    "endpoint_path": 1.5,
                    "description": 1.0,
                    "parameters": 0.8
                },
                "performance": {
                    "cache_size_mb": 32,
                    "max_results": 100
                }
            },
            "logging": {
                "level": "DEBUG",
                "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                "file": "./dev_server.log",
                "rotation": {"enabled": False}
            }
        }

    def get_production_template(self) -> Dict[str, Any]:
        """Production environment template with security and performance optimization"""
        return {
            "server": {
                "host": "0.0.0.0",
                "port": 8080,
                "max_connections": 100,
                "timeout": 30,
                "ssl": {
                    "enabled": True,
                    "cert_file": "/etc/ssl/certs/mcp-server.crt",
                    "key_file": "/etc/ssl/private/mcp-server.key"
                }
            },
            "database": {
                "path": "/var/lib/mcp-server/mcp_server.db",
                "pool_size": 10,
                "timeout": 10,
                "backup": {
                    "enabled": True,
                    "interval": 86400,
                    "retention": 7
                }
            },
            "search": {
                "engine": "whoosh",
                "index_directory": "/var/lib/mcp-server/search_index",
                "field_weights": {
                    "endpoint_path": 1.5,
                    "description": 1.0,
                    "parameters": 0.8
                },
                "performance": {
                    "cache_size_mb": 128,
                    "max_results": 1000
                }
            },
            "logging": {
                "level": "INFO",
                "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                "file": "/var/log/mcp-server/server.log",
                "rotation": {
                    "enabled": True,
                    "max_size_mb": 10,
                    "backup_count": 5
                }
            }
        }

    def get_staging_template(self) -> Dict[str, Any]:
        """Staging environment template balancing production settings with debugging"""
        return {
            "server": {
                "host": "0.0.0.0",
                "port": 8080,
                "max_connections": 50,
                "timeout": 30,
                "ssl": {"enabled": False}
            },
            "database": {
                "path": "/opt/mcp-server/staging_mcp_server.db",
                "pool_size": 5,
                "timeout": 15,
                "backup": {
                    "enabled": True,
                    "interval": 43200,  # 12 hours
                    "retention": 3
                }
            },
            "search": {
                "engine": "whoosh",
                "index_directory": "/opt/mcp-server/staging_search_index",
                "field_weights": {
                    "endpoint_path": 1.5,
                    "description": 1.0,
                    "parameters": 0.8
                },
                "performance": {
                    "cache_size_mb": 64,
                    "max_results": 500
                }
            },
            "logging": {
                "level": "INFO",
                "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                "file": "/var/log/mcp-server/staging_server.log",
                "rotation": {
                    "enabled": True,
                    "max_size_mb": 5,
                    "backup_count": 3
                }
            }
        }
```

### Environment Variable Integration
```python
class EnvironmentConfigExtractor:
    """Extracts configuration from environment variables"""

    ENV_PREFIX = "SWAGGER_MCP_"

    ENV_MAPPINGS = {
        "SWAGGER_MCP_SERVER_HOST": "server.host",
        "SWAGGER_MCP_SERVER_PORT": "server.port",
        "SWAGGER_MCP_SERVER_MAX_CONNECTIONS": "server.max_connections",
        "SWAGGER_MCP_SERVER_TIMEOUT": "server.timeout",
        "SWAGGER_MCP_SERVER_SSL_ENABLED": "server.ssl.enabled",
        "SWAGGER_MCP_SERVER_SSL_CERT": "server.ssl.cert_file",
        "SWAGGER_MCP_SERVER_SSL_KEY": "server.ssl.key_file",

        "SWAGGER_MCP_DB_PATH": "database.path",
        "SWAGGER_MCP_DB_POOL_SIZE": "database.pool_size",
        "SWAGGER_MCP_DB_TIMEOUT": "database.timeout",

        "SWAGGER_MCP_SEARCH_INDEX_DIR": "search.index_directory",
        "SWAGGER_MCP_SEARCH_CACHE_SIZE": "search.performance.cache_size_mb",
        "SWAGGER_MCP_SEARCH_MAX_RESULTS": "search.performance.max_results",

        "SWAGGER_MCP_LOG_LEVEL": "logging.level",
        "SWAGGER_MCP_LOG_FILE": "logging.file",
    }

    def extract_environment_config(self) -> Dict[str, Any]:
        """Extract configuration from environment variables"""

        config = {}

        for env_var, config_path in self.ENV_MAPPINGS.items():
            if env_var in os.environ:
                value = self.convert_env_value(os.environ[env_var], config_path)
                self.set_nested_config(config, config_path, value)

        return config

    def convert_env_value(self, env_value: str, config_path: str) -> Union[str, int, bool, float]:
        """Convert environment variable value to appropriate type"""

        # Boolean conversion
        if config_path.endswith(('.enabled', '.ssl.enabled')):
            return env_value.lower() in ('true', '1', 'yes', 'on')

        # Integer conversion
        if config_path.endswith(('.port', '.max_connections', '.timeout', '.pool_size',
                               '.cache_size_mb', '.max_results')):
            try:
                return int(env_value)
            except ValueError:
                raise ConfigurationError(f"Invalid integer value for {config_path}: {env_value}")

        # Float conversion
        if 'field_weights' in config_path:
            try:
                return float(env_value)
            except ValueError:
                raise ConfigurationError(f"Invalid float value for {config_path}: {env_value}")

        # String value (default)
        return env_value

    def set_nested_config(self, config: Dict[str, Any], path: str, value: Any):
        """Set nested configuration value using dot notation"""

        keys = path.split('.')
        current = config

        for key in keys[:-1]:
            if key not in current:
                current[key] = {}
            current = current[key]

        current[keys[-1]] = value

    def get_environment_documentation(self) -> Dict[str, str]:
        """Get documentation for environment variables"""

        return {
            "SWAGGER_MCP_SERVER_HOST": "Server host address (default: localhost)",
            "SWAGGER_MCP_SERVER_PORT": "Server port number (default: 8080)",
            "SWAGGER_MCP_SERVER_MAX_CONNECTIONS": "Maximum concurrent connections (default: 100)",
            "SWAGGER_MCP_SERVER_TIMEOUT": "Connection timeout in seconds (default: 30)",

            "SWAGGER_MCP_DB_PATH": "Database file path (default: ./mcp_server.db)",
            "SWAGGER_MCP_DB_POOL_SIZE": "Database connection pool size (default: 5)",

            "SWAGGER_MCP_SEARCH_INDEX_DIR": "Search index directory (default: ./search_index)",
            "SWAGGER_MCP_SEARCH_CACHE_SIZE": "Search cache size in MB (default: 64)",

            "SWAGGER_MCP_LOG_LEVEL": "Logging level: DEBUG, INFO, WARNING, ERROR (default: INFO)",
            "SWAGGER_MCP_LOG_FILE": "Log file path (default: None - console only)",
        }
```

### Configuration Validation and Help
```python
async def handle_config_show(manager: ConfigurationManager, key: Optional[str],
                           config_file: Optional[str], format: str):
    """Handle configuration show command"""

    config = await manager.load_configuration(config_file)

    if key:
        # Show specific configuration key
        value = get_nested_config_value(config, key)
        if value is None:
            click.echo(f"Configuration key '{key}' not found")
            return

        if format == "json":
            click.echo(json.dumps({key: value}, indent=2))
        else:
            click.echo(f"{key}: {value}")

    else:
        # Show all configuration
        if format == "json":
            click.echo(json.dumps(config, indent=2))
        else:
            display_config_yaml(config)

def display_config_yaml(config: Dict[str, Any]):
    """Display configuration in YAML format with comments"""

    click.echo("# MCP Server Configuration")
    click.echo("# Generated by swagger-mcp-server")
    click.echo(f"# Timestamp: {datetime.now().isoformat()}")
    click.echo()

    yaml_output = yaml.dump(config, default_flow_style=False, sort_keys=False)
    click.echo(yaml_output)

async def handle_config_validate(manager: ConfigurationManager, config_file: Optional[str]):
    """Handle configuration validation"""

    try:
        config = await manager.load_configuration(config_file)
        click.echo("✅ Configuration is valid")

        # Show any warnings or recommendations
        warnings = manager.get_configuration_warnings(config)
        if warnings:
            click.echo("\n⚠️  Configuration warnings:")
            for warning in warnings:
                click.echo(f"   - {warning}")

    except ConfigurationError as e:
        click.echo("❌ Configuration validation failed:")
        for field, errors in e.errors.items():
            click.echo(f"   {field}: {', '.join(errors)}")

def get_configuration_help(key: str) -> str:
    """Get help text for configuration option"""

    help_text = {
        "server.host": "Server host address. Use '0.0.0.0' to accept connections from any IP.",
        "server.port": "Server port number. Must be between 1024-65535.",
        "server.max_connections": "Maximum number of concurrent client connections.",
        "server.timeout": "Connection timeout in seconds.",

        "database.path": "SQLite database file path. Can be relative or absolute.",
        "database.pool_size": "Database connection pool size for concurrent operations.",

        "search.field_weights.endpoint_path": "Weight for endpoint path matching in search results.",
        "search.field_weights.description": "Weight for description text in search ranking.",
        "search.field_weights.parameters": "Weight for parameter matching in search results.",

        "logging.level": "Logging verbosity: DEBUG, INFO, WARNING, ERROR.",
        "logging.file": "Log file path. If not specified, logs to console only.",
    }

    return help_text.get(key, f"No help available for '{key}'")
```

## Definition of Done
- [x] Config command implemented with show, set, reset, init, validate, and env-help actions
- [x] Configuration file generation with sensible defaults and comprehensive documentation
- [x] Environment variable override system with systematic mapping and validation
- [x] Server configuration customization for host, port, connections, timeouts, SSL/TLS
- [x] Search engine configuration for field weights, performance tuning, and indexing options
- [x] Configuration templates for development, staging, production, and container deployment scenarios
- [x] Configuration validation with clear error messages and schema enforcement
- [x] Nested configuration management using dot notation for complex settings
- [x] Configuration backup and restore capabilities with rollback functionality
- [x] Configuration help system with contextual guidance and examples
- [x] Environment variable documentation and discovery for operational deployments
- [x] Comprehensive unit tests for configuration management components (≥95% coverage)
- [x] Integration tests validate configuration hierarchy and precedence rules
- [x] Template testing ensures all deployment scenarios work with generated configurations
- [x] Cross-field validation for SSL configuration and file path dependencies
- [x] Configuration examples and documentation with deployment-specific guidance

## Dev Agent Record
**Completion Date**: 2024-01-15
**Implementation Summary**:
- Implemented comprehensive configuration management system with ConfigurationManager, ConfigurationSchema, EnvironmentConfigExtractor, and ConfigurationTemplateManager
- Created complete CLI integration with config command supporting all required actions
- Built validation system with type checking, range validation, and cross-field constraints
- Developed four deployment templates (development, staging, production, container) with environment-specific optimizations
- Implemented environment variable override system with systematic naming and type conversion
- Created comprehensive test suite covering all components with integration testing
- Added configuration backup system and validation warnings for operational safety
- Generated complete documentation and examples for all deployment scenarios

## Validation Criteria
- Configuration management supports both simple and complex deployment scenarios effectively
- Environment variable overrides enable container and cloud deployment without file modifications
- Configuration templates provide appropriate defaults for different deployment environments
- Validation prevents invalid configurations from causing system failures
- Configuration help system enables users to understand and optimize settings independently
- Configuration changes can be applied safely with rollback capabilities when needed

## Risk Assessment
**Medium Risk** - Configuration complexity and validation accuracy challenges

**Primary Risks:**
- Configuration schema complexity causing validation and user experience issues
- Environment variable mapping complexity affecting deployment automation
- Configuration template maintenance overhead as system features expand
- Cross-platform path handling and environment variable differences

**Mitigation Strategies:**
- Simple, well-documented configuration schema with clear validation messages
- Systematic environment variable naming conventions with comprehensive documentation
- Automated testing of configuration templates with different deployment scenarios
- Cross-platform testing throughout development with CI/CD validation
- User testing with target deployment scenarios to validate usability

**Rollback Plan:**
- Simplify configuration to basic key-value pairs if nested configuration causes issues
- Remove environment variable overrides if mapping complexity becomes problematic
- Provide only basic development template if multiple templates cause maintenance issues
- Fall back to manual configuration editing if automated management fails

## Story Estimation
**Complexity**: Medium
**Effort**: 3-4 development sessions (12-16 hours)
**Risk Level**: Medium
**Dependencies**: 3 (Stories 4.1, 4.2, 4.3)