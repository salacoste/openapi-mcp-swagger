"""Deployment package generation for converted MCP servers."""

import os
import json
import shutil
import stat
from datetime import datetime
from pathlib import Path
from typing import Dict, Any
import structlog

from .. import __version__


logger = structlog.get_logger(__name__)


class DeploymentPackageGenerator:
    """Generates complete MCP server deployment package."""

    def __init__(self, output_dir: str):
        self.output_dir = output_dir

    async def create_deployment_package(self, server_config: Dict[str, Any]) -> str:
        """Create complete deployment package with all necessary files."""
        try:
            logger.info("Creating deployment package", output_dir=self.output_dir)

            # Generate main server files
            await self._generate_server_main(server_config)
            await self._generate_configuration_files(server_config)
            await self._generate_startup_scripts(server_config)

            # Generate documentation and examples
            await self._generate_readme(server_config)
            await self._generate_usage_examples(server_config)

            # Generate deployment configurations
            await self._generate_requirements_file(server_config)
            await self._generate_docker_config(server_config)
            await self._generate_systemd_service(server_config)

            # Generate environment and gitignore files
            await self._generate_env_file(server_config)
            await self._generate_gitignore()

            logger.info("Deployment package created successfully")
            return self.output_dir

        except Exception as e:
            logger.error("Failed to create deployment package", error=str(e))
            raise

    async def _generate_server_main(self, config: Dict[str, Any]):
        """Generate main MCP server implementation."""
        server_template = '''#!/usr/bin/env python3
"""
Generated MCP Server for {api_title}

This file was automatically generated by swagger-mcp-server
from the Swagger specification: {swagger_file}

Generated on: {generation_date}
API Version: {api_version}
"""

import asyncio
import os
import sys
from pathlib import Path

# Add the swagger_mcp_server package to Python path
sys.path.insert(0, str(Path(__file__).parent))

try:
    from swagger_mcp_server.server.mcp_server import MCPServer
    from swagger_mcp_server.storage.database import Database
    from swagger_mcp_server.search.search_engine import SearchEngine
    from swagger_mcp_server.search.index_manager import SearchIndexManager
    from swagger_mcp_server.config.settings import Settings
except ImportError as e:
    print(f"Error importing required modules: {{e}}")
    print("Please ensure swagger-mcp-server is properly installed:")
    print("  pip install -r requirements.txt")
    sys.exit(1)

import structlog

# Configure logging
structlog.configure(
    processors=[
        structlog.dev.ConsoleRenderer(colors=True)
    ],
    wrapper_class=structlog.make_filtering_bound_logger(20),  # INFO level
    logger_factory=structlog.WriteLoggerFactory(),
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger(__name__)


class {server_class_name}:
    """Generated MCP Server for {api_title}."""

    def __init__(self):
        self.config = self._load_config()
        self.database = None
        self.search_engine = None
        self.mcp_server = None

    def _load_config(self) -> Dict[str, Any]:
        """Load server configuration."""
        base_config = {{
            "api_title": "{api_title}",
            "api_version": "{api_version}",
            "server_name": "{server_name}",
            "host": "{host}",
            "port": {port},
            "database_path": "{database_path}",
            "search_index_path": "{search_index_path}",
        }}

        # Load from config file if exists
        config_file = Path(__file__).parent / "config" / "server.yaml"
        if config_file.exists():
            try:
                import yaml
                with open(config_file) as f:
                    file_config = yaml.safe_load(f) or {{}}
                base_config.update(file_config)
            except ImportError:
                logger.warning("PyYAML not installed, using default configuration")
            except Exception as e:
                logger.warning("Failed to load config file", error=str(e))

        # Override with environment variables
        env_overrides = {{
            "host": os.getenv("MCP_HOST"),
            "port": os.getenv("MCP_PORT"),
            "database_path": os.getenv("MCP_DATABASE_PATH"),
        }}

        for key, value in env_overrides.items():
            if value is not None:
                if key == "port":
                    try:
                        base_config[key] = int(value)
                    except ValueError:
                        logger.warning("Invalid port value in environment", port=value)
                else:
                    base_config[key] = value

        return base_config

    async def initialize(self):
        """Initialize database and search components."""
        try:
            logger.info("Initializing MCP server components")

            # Initialize database
            database_path = self.config["database_path"]
            if not os.path.isabs(database_path):
                database_path = os.path.join(os.path.dirname(__file__), database_path)

            self.database = Database(database_path)
            await self.database.connect()
            logger.info("Database connected", path=database_path)

            # Initialize search engine
            search_index_path = self.config["search_index_path"]
            if not os.path.isabs(search_index_path):
                search_index_path = os.path.join(os.path.dirname(__file__), search_index_path)

            index_manager = SearchIndexManager(search_index_path)
            self.search_engine = SearchEngine(index_manager, {{}})
            logger.info("Search engine initialized", path=search_index_path)

            # Initialize MCP server
            settings = Settings()
            self.mcp_server = MCPServer(
                database=self.database,
                search_engine=self.search_engine,
                settings=settings
            )
            logger.info("MCP server initialized")

        except Exception as e:
            logger.error("Failed to initialize server components", error=str(e))
            raise

    async def start(self):
        """Start the MCP server."""
        try:
            await self.initialize()

            logger.info("Starting MCP server for {{}}".format(self.config["api_title"]))
            logger.info("Server configuration:")
            logger.info("  API: {{}} v{{}}".format(
                self.config["api_title"],
                self.config["api_version"]
            ))
            logger.info("  Host: {{}}".format(self.config["host"]))
            logger.info("  Port: {{}}".format(self.config["port"]))
            logger.info("  Database: {{}}".format(self.config["database_path"]))

            print("\\n🚀 MCP Server is starting...")
            print(f"📊 API: {{self.config['api_title']}} v{{self.config['api_version']}}")
            print(f"🌐 Server URL: http://{{self.config['host']}}:{{self.config['port']}}")
            print(f"📚 Available MCP methods: searchEndpoints, getSchema, getExample")
            print(f"🤖 AI agents can now connect and query API documentation")
            print("\\n📋 To stop the server, press Ctrl+C")
            print("📖 For usage examples, see README.md")

            # Start the MCP server
            await self.mcp_server.start(
                host=self.config["host"],
                port=self.config["port"]
            )

        except KeyboardInterrupt:
            logger.info("Shutting down server")
            print("\\n👋 Server shutting down...")
        except Exception as e:
            logger.error("Server error", error=str(e))
            print(f"\\n❌ Server error: {{e}}")
            raise
        finally:
            await self.cleanup()

    async def cleanup(self):
        """Clean up resources."""
        try:
            if self.mcp_server:
                await self.mcp_server.stop()
            if self.database:
                await self.database.close()
        except Exception as e:
            logger.error("Error during cleanup", error=str(e))


async def main():
    """Main entry point."""
    server = {server_class_name}()
    await server.start()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\\n👋 Goodbye!")
    except Exception as e:
        print(f"\\n❌ Fatal error: {{e}}")
        sys.exit(1)
'''

        # Generate class name from server name
        server_class_name = self._generate_class_name(config["server_name"])

        server_content = server_template.format(
            api_title=config["api_title"],
            api_version=config["api_version"],
            swagger_file=config["swagger_file"],
            generation_date=config["generation_date"],
            server_name=config["server_name"],
            server_class_name=server_class_name,
            host=config["host"],
            port=config["port"],
            database_path=config["database_path"],
            search_index_path=config["search_index_path"],
        )

        server_path = os.path.join(self.output_dir, "server.py")
        with open(server_path, 'w', encoding='utf-8') as f:
            f.write(server_content)

        # Make executable
        st = os.stat(server_path)
        os.chmod(server_path, st.st_mode | stat.S_IEXEC)

    def _generate_class_name(self, server_name: str) -> str:
        """Generate a valid Python class name from server name."""
        import re
        # Convert to PascalCase
        words = re.findall(r'[a-zA-Z0-9]+', server_name)
        class_name = ''.join(word.capitalize() for word in words)
        return class_name + "MCPServer" if class_name else "GeneratedMCPServer"

    async def _generate_configuration_files(self, config: Dict[str, Any]):
        """Generate configuration files."""
        # Server configuration in YAML format
        server_config = {
            "server": {
                "host": config["host"],
                "port": config["port"],
                "name": config["server_name"],
            },
            "api": {
                "title": config["api_title"],
                "version": config["api_version"],
                "description": config.get("api_description", ""),
            },
            "database": {
                "path": os.path.relpath(config["database_path"], self.output_dir),
                "backup_enabled": True,
                "backup_interval": 3600,  # 1 hour
            },
            "search": {
                "index_path": os.path.relpath(config["search_index_path"], self.output_dir),
                "cache_size": 1000,
                "enable_fuzzy": True,
            },
            "logging": {
                "level": "INFO",
                "format": "console",
                "file": None,
            },
            "security": {
                "enable_auth": False,
                "api_key": None,
                "allowed_hosts": ["localhost", "127.0.0.1"],
            }
        }

        config_dir = os.path.join(self.output_dir, "config")
        os.makedirs(config_dir, exist_ok=True)

        # Write YAML config
        config_path = os.path.join(config_dir, "server.yaml")
        try:
            import yaml
            with open(config_path, 'w', encoding='utf-8') as f:
                yaml.dump(server_config, f, default_flow_style=False, indent=2)
        except ImportError:
            # Fallback to JSON if PyYAML not available
            config_path = os.path.join(config_dir, "server.json")
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(server_config, f, indent=2)

    async def _generate_startup_scripts(self, config: Dict[str, Any]):
        """Generate startup scripts for different platforms."""
        # Unix/Linux startup script
        unix_script = f'''#!/bin/bash
# Startup script for {config["server_name"]} MCP Server

set -e

# Change to script directory
cd "$(dirname "$0")"

# Check Python version
python3 --version >/dev/null 2>&1 || {{
    echo "Error: Python 3 is required but not found"
    exit 1
}}

# Check if virtual environment exists
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python3 -m venv venv
fi

# Activate virtual environment
source venv/bin/activate

# Install dependencies
if [ -f "requirements.txt" ]; then
    echo "Installing dependencies..."
    pip install -r requirements.txt
fi

# Start server
echo "Starting {config['api_title']} MCP Server..."
python server.py "$@"
'''

        unix_script_path = os.path.join(self.output_dir, "start.sh")
        with open(unix_script_path, 'w', encoding='utf-8') as f:
            f.write(unix_script)

        # Make executable
        st = os.stat(unix_script_path)
        os.chmod(unix_script_path, st.st_mode | stat.S_IEXEC)

        # Windows batch script
        windows_script = f'''@echo off
rem Startup script for {config["server_name"]} MCP Server

cd /d "%~dp0"

rem Check if Python is available
python --version >nul 2>&1
if errorlevel 1 (
    echo Error: Python is required but not found
    exit /b 1
)

rem Check if virtual environment exists
if not exist "venv" (
    echo Creating virtual environment...
    python -m venv venv
)

rem Activate virtual environment
call venv\\Scripts\\activate.bat

rem Install dependencies
if exist "requirements.txt" (
    echo Installing dependencies...
    pip install -r requirements.txt
)

rem Start server
echo Starting {config['api_title']} MCP Server...
python server.py %*
'''

        windows_script_path = os.path.join(self.output_dir, "start.bat")
        with open(windows_script_path, 'w', encoding='utf-8') as f:
            f.write(windows_script)

    async def _generate_readme(self, config: Dict[str, Any]):
        """Generate comprehensive README for converted MCP server."""
        readme_template = f'''# MCP Server for {config["api_title"]}

Generated MCP server providing intelligent access to {config["api_title"]} API documentation.

## Overview

This MCP server was automatically generated from your Swagger/OpenAPI specification and provides three main capabilities:

- **🔍 Intelligent Endpoint Search**: Find API endpoints by functionality using natural language queries
- **📋 Schema Retrieval**: Get detailed schema definitions with full type information and relationships
- **💻 Code Generation**: Generate working code examples in multiple programming languages

## Quick Start

### Prerequisites
- Python 3.8 or higher
- pip (Python package installer)

### Option 1: Automatic Setup (Recommended)
```bash
# Unix/Linux/macOS
./start.sh

# Windows
start.bat
```

### Option 2: Manual Setup
```bash
# Create virtual environment
python -m venv venv

# Activate virtual environment
# On Unix/Linux/macOS:
source venv/bin/activate
# On Windows:
venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt

# Start the server
python server.py
```

### Verify Installation
Once started, the server will display:
```
🚀 MCP Server is starting...
📊 API: {config["api_title"]} v{config["api_version"]}
🌐 Server URL: http://localhost:{config["port"]}
📚 Available MCP methods: searchEndpoints, getSchema, getExample
🤖 AI agents can now connect and query API documentation
```

## API Information

- **API Title**: {config["api_title"]}
- **Version**: {config["api_version"]}
- **Total Endpoints**: {config["endpoint_count"]}
- **Schema Components**: {config["schema_count"]}
- **Generated**: {datetime.fromisoformat(config["generation_date"]).strftime("%Y-%m-%d %H:%M:%S")}

## MCP Methods

### searchEndpoints
Search for API endpoints using natural language queries.

**Parameters:**
- `keywords` (string): Search terms describing the functionality
- `httpMethods` (optional array): Filter by HTTP methods (GET, POST, etc.)
- `tags` (optional array): Filter by OpenAPI tags

**Example:**
```python
# Search for user-related endpoints
results = await client.searchEndpoints("user management")

# Search for authentication endpoints
results = await client.searchEndpoints("login authentication", ["POST"])
```

### getSchema
Retrieve detailed schema definitions with relationships.

**Parameters:**
- `componentName` (string): Name of the schema component
- `maxDepth` (optional number): Maximum relationship depth (1-10)

**Example:**
```python
# Get user schema with dependencies
schema = await client.getSchema("User")

# Get schema with limited depth
schema = await client.getSchema("UserProfile", maxDepth=2)
```

### getExample
Generate code examples for API endpoints.

**Parameters:**
- `endpoint` (string): API endpoint path
- `format` (string): Output format (curl, python, javascript, etc.)
- `method` (optional string): HTTP method

**Example:**
```python
# Get cURL example
curl_example = await client.getExample("/api/v1/users/{{id}}", "curl")

# Get Python example
python_example = await client.getExample("/api/v1/users", "python", "POST")
```

## Configuration

Edit `config/server.yaml` to customize server behavior:

```yaml
server:
  host: localhost      # Server host
  port: {config["port"]}            # Server port
  name: {config["server_name"]}

database:
  path: {os.path.relpath(config["database_path"], self.output_dir)}     # SQLite database path
  backup_enabled: true

search:
  index_path: {os.path.relpath(config["search_index_path"], self.output_dir)}  # Search index location
  cache_size: 1000     # Search result cache size
  enable_fuzzy: true   # Enable fuzzy matching

logging:
  level: INFO          # Log level (DEBUG, INFO, WARNING, ERROR)
  format: console      # Log format
```

## Environment Variables

Override configuration with environment variables:

- `MCP_HOST`: Server host (default: localhost)
- `MCP_PORT`: Server port (default: {config["port"]})
- `MCP_DATABASE_PATH`: Database file path

Example:
```bash
export MCP_PORT=9000
python server.py
```

## Deployment

### Local Development
```bash
python server.py
```

### Docker (if Dockerfile is present)
```bash
docker build -t mcp-server-{config["server_name"]} .
docker run -p {config["port"]}:{config["port"]} mcp-server-{config["server_name"]}
```

### Production with systemd (Linux)
```bash
# Copy service file
sudo cp mcp-server.service /etc/systemd/system/

# Enable and start service
sudo systemctl enable mcp-server
sudo systemctl start mcp-server

# Check status
sudo systemctl status mcp-server
```

## Troubleshooting

### Common Issues

**Port already in use:**
```bash
# Check what's using the port
lsof -i :{config["port"]}

# Use a different port
export MCP_PORT=9000
python server.py
```

**Module import errors:**
```bash
# Ensure dependencies are installed
pip install -r requirements.txt

# Check Python path
python -c "import sys; print(sys.path)"
```

**Database errors:**
```bash
# Remove database to regenerate
rm {config["database_path"]}
python server.py
```

**Search index issues:**
```bash
# Remove search index to regenerate
rm -rf {config["search_index_path"]}
python server.py
```

### Debug Mode
Run with verbose logging:
```bash
python server.py --verbose
```

### Performance Tuning
For high-traffic deployments:
1. Increase search cache size in `config/server.yaml`
2. Enable database connection pooling
3. Use a reverse proxy (nginx, Apache)
4. Monitor with the built-in health endpoints

## File Structure

```
{config["server_name"]}/
├── server.py              # Main MCP server
├── start.sh              # Unix startup script
├── start.bat             # Windows startup script
├── requirements.txt      # Python dependencies
├── README.md             # This file
├── config/
│   └── server.yaml      # Server configuration
├── data/
│   ├── mcp_server.db    # SQLite database
│   └── search_index/    # Search index files
└── docs/
    └── examples.md      # Usage examples
```

## Support

- **Original Swagger file**: `{config["swagger_file"]}`
- **Generated by**: swagger-mcp-server v{__version__}
- **Documentation**: https://docs.swagger-mcp-server.com
- **Issues**: https://github.com/swagger-mcp-server/issues

## License

This generated MCP server inherits the license from the original Swagger specification.
'''

        readme_path = os.path.join(self.output_dir, "README.md")
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme_template)

    async def _generate_usage_examples(self, config: Dict[str, Any]):
        """Generate detailed usage examples."""
        examples_content = f'''# Usage Examples for {config["api_title"]} MCP Server

This document provides comprehensive examples for using the generated MCP server.

## Connection Examples

### Python MCP Client
```python
import asyncio
from mcp_client import MCPClient

async def main():
    client = MCPClient("http://localhost:{config['port']}")
    await client.connect()

    # Search for endpoints
    results = await client.searchEndpoints("user management")
    print(f"Found {{len(results['results'])}} endpoints")

    # Get schema information
    schema = await client.getSchema("User")
    print(f"User schema: {{schema}}")

    # Generate code example
    example = await client.getExample("/api/v1/users", "python")
    print(f"Python example:\\n{{example}}")

    await client.disconnect()

asyncio.run(main())
```

### JavaScript/Node.js MCP Client
```javascript
const {{ MCPClient }} = require('mcp-client');

async function main() {{
    const client = new MCPClient('http://localhost:{config['port']}');
    await client.connect();

    // Search for endpoints
    const results = await client.searchEndpoints('user management');
    console.log(`Found ${{results.results.length}} endpoints`);

    // Get schema information
    const schema = await client.getSchema('User');
    console.log('User schema:', schema);

    // Generate code example
    const example = await client.getExample('/api/v1/users', 'javascript');
    console.log('JavaScript example:\\n', example);

    await client.disconnect();
}}

main().catch(console.error);
```

## Search Examples

### Basic Endpoint Search
```python
# Search for user-related functionality
results = await client.searchEndpoints("user profile management")

# Search for authentication endpoints
auth_results = await client.searchEndpoints("login logout authentication")

# Search for file operations
file_results = await client.searchEndpoints("upload download file")
```

### Filtered Search
```python
# Only GET endpoints
get_endpoints = await client.searchEndpoints(
    "user data",
    httpMethods=["GET"]
)

# Only POST and PUT endpoints
modify_endpoints = await client.searchEndpoints(
    "user creation update",
    httpMethods=["POST", "PUT"]
)

# Search by tags
tagged_endpoints = await client.searchEndpoints(
    "user management",
    tags=["users", "admin"]
)
```

### Advanced Search Patterns
```python
# Search for specific functionality
payment_endpoints = await client.searchEndpoints("payment processing checkout")
notification_endpoints = await client.searchEndpoints("notification email sms")
reporting_endpoints = await client.searchEndpoints("reports analytics statistics")

# Search for CRUD operations
crud_examples = [
    await client.searchEndpoints("create new user", ["POST"]),
    await client.searchEndpoints("get user details", ["GET"]),
    await client.searchEndpoints("update user profile", ["PUT", "PATCH"]),
    await client.searchEndpoints("delete user account", ["DELETE"])
]
```

## Schema Examples

### Basic Schema Retrieval
```python
# Get complete schema with all relationships
user_schema = await client.getSchema("User")

# Get schema with limited depth to avoid deep nesting
profile_schema = await client.getSchema("UserProfile", maxDepth=2)

# Get multiple related schemas
schemas = []
for schema_name in ["User", "Address", "ContactInfo"]:
    schema = await client.getSchema(schema_name)
    schemas.append(schema)
```

### Working with Schema Data
```python
# Extract schema properties
user_schema = await client.getSchema("User")
properties = user_schema.get("schema", {{}}).get("properties", {{}})

print("User properties:")
for prop_name, prop_def in properties.items():
    prop_type = prop_def.get("type", "unknown")
    required = prop_name in user_schema.get("schema", {{}}).get("required", [])
    print(f"  {{prop_name}}: {{prop_type}} {{'(required)' if required else ''}}")
```

## Code Generation Examples

### cURL Examples
```python
# GET request example
curl_get = await client.getExample("/api/v1/users/{{id}}", "curl", "GET")
print(curl_get)
# Output: curl -X GET "http://api.example.com/api/v1/users/123" -H "Accept: application/json"

# POST request example
curl_post = await client.getExample("/api/v1/users", "curl", "POST")
print(curl_post)
# Output: curl -X POST "http://api.example.com/api/v1/users" -H "Content-Type: application/json" -d '{{"name": "John Doe", "email": "john@example.com"}}'
```

### Python Examples
```python
# Python requests example
python_example = await client.getExample("/api/v1/users", "python", "POST")
print(python_example)
# Output:
# import requests
#
# url = "http://api.example.com/api/v1/users"
# payload = {{"name": "John Doe", "email": "john@example.com"}}
# response = requests.post(url, json=payload)
# print(response.json())
```

### JavaScript Examples
```python
# JavaScript fetch example
js_example = await client.getExample("/api/v1/users/{{id}}", "javascript", "GET")
print(js_example)
# Output:
# fetch('http://api.example.com/api/v1/users/123', {{
#   method: 'GET',
#   headers: {{
#     'Accept': 'application/json'
#   }}
# }})
# .then(response => response.json())
# .then(data => console.log(data));
```

## Integration Patterns

### AI Agent Integration
```python
class APIAssistant:
    def __init__(self, mcp_client):
        self.client = mcp_client

    async def find_endpoint_for_task(self, task_description):
        """Find the best endpoint for a given task."""
        results = await self.client.searchEndpoints(task_description)

        if results['results']:
            best_match = results['results'][0]  # Highest ranked result

            # Get code example for the endpoint
            example = await self.client.getExample(
                best_match['path'],
                "python",
                best_match['method']
            )

            return {{
                'endpoint': best_match,
                'code_example': example,
                'confidence': best_match.get('score', 0)
            }}

        return None

# Usage
assistant = APIAssistant(mcp_client)
result = await assistant.find_endpoint_for_task("create a new user account")
```

### Batch Processing
```python
async def process_multiple_queries(client, queries):
    """Process multiple search queries efficiently."""
    tasks = []

    for query in queries:
        task = client.searchEndpoints(query)
        tasks.append(task)

    results = await asyncio.gather(*tasks)

    return dict(zip(queries, results))

# Example usage
queries = [
    "user authentication",
    "file upload",
    "payment processing",
    "email notifications"
]

batch_results = await process_multiple_queries(client, queries)
```

## Error Handling

### Connection Errors
```python
from mcp_client import MCPClient, ConnectionError

async def robust_connection():
    client = MCPClient("http://localhost:{config['port']}")

    try:
        await client.connect()
        return client
    except ConnectionError:
        print("Server not running. Please start the MCP server first.")
        return None
    except Exception as e:
        print(f"Unexpected connection error: {{e}}")
        return None
```

### Query Errors
```python
async def safe_search(client, query):
    try:
        results = await client.searchEndpoints(query)
        return results
    except ValueError as e:
        print(f"Invalid query: {{e}}")
        return {{'results': [], 'error': str(e)}}
    except Exception as e:
        print(f"Search error: {{e}}")
        return {{'results': [], 'error': str(e)}}
```

## Performance Tips

### Connection Pooling
```python
class MCPPool:
    def __init__(self, server_url, pool_size=5):
        self.server_url = server_url
        self.pool_size = pool_size
        self.clients = []
        self.available = asyncio.Queue()

    async def initialize(self):
        for _ in range(self.pool_size):
            client = MCPClient(self.server_url)
            await client.connect()
            self.clients.append(client)
            await self.available.put(client)

    async def get_client(self):
        return await self.available.get()

    async def return_client(self, client):
        await self.available.put(client)
```

### Caching Results
```python
from functools import lru_cache
import asyncio

class CachedMCPClient:
    def __init__(self, client):
        self.client = client
        self.schema_cache = {{}}

    async def searchEndpoints(self, query, **kwargs):
        # Searches are dynamic, don't cache
        return await self.client.searchEndpoints(query, **kwargs)

    async def getSchema(self, component_name, max_depth=None):
        cache_key = f"{{component_name}}:{{max_depth}}"

        if cache_key not in self.schema_cache:
            result = await self.client.getSchema(component_name, max_depth)
            self.schema_cache[cache_key] = result

        return self.schema_cache[cache_key]
```

This completes the usage examples for your generated MCP server.
'''

        docs_dir = os.path.join(self.output_dir, "docs")
        os.makedirs(docs_dir, exist_ok=True)

        examples_path = os.path.join(docs_dir, "examples.md")
        with open(examples_path, 'w', encoding='utf-8') as f:
            f.write(examples_content)

    async def _generate_requirements_file(self, config: Dict[str, Any]):
        """Generate Python requirements file."""
        requirements = [
            "# Generated requirements for MCP Server",
            f"# API: {config['api_title']} v{config['api_version']}",
            f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "# Core MCP Server dependencies",
            "swagger-mcp-server>=0.1.0",
            "",
            "# Optional dependencies for enhanced functionality",
            "pyyaml>=6.0.1  # For YAML configuration files",
            "uvloop>=0.17.0  # For improved async performance (Unix only)",
            "",
            "# Development dependencies (optional)",
            "# pytest>=7.4.0",
            "# pytest-asyncio>=0.21.0",
            "# black>=23.0.0",
            "# mypy>=1.0.0",
        ]

        requirements_path = os.path.join(self.output_dir, "requirements.txt")
        with open(requirements_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(requirements))

    async def _generate_docker_config(self, config: Dict[str, Any]):
        """Generate Docker configuration."""
        dockerfile_content = f'''# Dockerfile for {config["api_title"]} MCP Server
# Generated by swagger-mcp-server

FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash mcp
RUN chown -R mcp:mcp /app
USER mcp

# Expose port
EXPOSE {config["port"]}

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD python -c "import requests; requests.get('http://localhost:{config["port"]}/health')" || exit 1

# Run server
CMD ["python", "server.py"]
'''

        dockerfile_path = os.path.join(self.output_dir, "Dockerfile")
        with open(dockerfile_path, 'w', encoding='utf-8') as f:
            f.write(dockerfile_content)

        # Docker Compose file
        compose_content = f'''version: '3.8'

services:
  mcp-server:
    build: .
    container_name: {config["server_name"]}-mcp
    ports:
      - "{config["port"]}:{config["port"]}"
    environment:
      - MCP_HOST=0.0.0.0
      - MCP_PORT={config["port"]}
    volumes:
      - ./data:/app/data
      - ./config:/app/config
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:{config["port"]}/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Optional: Add a reverse proxy
  # nginx:
  #   image: nginx:alpine
  #   ports:
  #     - "80:80"
  #   volumes:
  #     - ./nginx.conf:/etc/nginx/nginx.conf
  #   depends_on:
  #     - mcp-server
'''

        compose_path = os.path.join(self.output_dir, "docker-compose.yml")
        with open(compose_path, 'w', encoding='utf-8') as f:
            f.write(compose_content)

    async def _generate_systemd_service(self, config: Dict[str, Any]):
        """Generate systemd service file."""
        service_content = f'''[Unit]
Description={config["api_title"]} MCP Server
After=network.target
Wants=network.target

[Service]
Type=simple
User=mcp
Group=mcp
WorkingDirectory=/opt/{config["server_name"]}
Environment=PATH=/opt/{config["server_name"]}/venv/bin
ExecStart=/opt/{config["server_name"]}/venv/bin/python server.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/{config["server_name"]}/data

# Environment variables
Environment=MCP_HOST=0.0.0.0
Environment=MCP_PORT={config["port"]}

[Install]
WantedBy=multi-user.target
'''

        service_path = os.path.join(self.output_dir, "mcp-server.service")
        with open(service_path, 'w', encoding='utf-8') as f:
            f.write(service_content)

    async def _generate_env_file(self, config: Dict[str, Any]):
        """Generate environment variables template."""
        env_content = f'''# Environment variables for {config["api_title"]} MCP Server
# Copy this file to .env and customize as needed

# Server configuration
MCP_HOST=localhost
MCP_PORT={config["port"]}

# Database configuration
MCP_DATABASE_PATH={config["database_path"]}

# Logging configuration
MCP_LOG_LEVEL=INFO
MCP_LOG_FORMAT=console

# Security configuration (optional)
# MCP_API_KEY=your-secret-api-key
# MCP_ALLOWED_HOSTS=localhost,127.0.0.1,your-domain.com

# Performance tuning (optional)
# MCP_SEARCH_CACHE_SIZE=1000
# MCP_MAX_CONNECTIONS=100
'''

        env_path = os.path.join(self.output_dir, ".env.example")
        with open(env_path, 'w', encoding='utf-8') as f:
            f.write(env_content)

    async def _generate_gitignore(self):
        """Generate .gitignore file."""
        gitignore_content = '''# Generated MCP Server .gitignore

# Environment variables
.env

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
env/
ENV/

# Database files
*.db
*.sqlite
*.sqlite3

# Search index
search_index/

# Logs
*.log
logs/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Temporary files
tmp/
temp/
*.tmp
'''

        gitignore_path = os.path.join(self.output_dir, ".gitignore")
        with open(gitignore_path, 'w', encoding='utf-8') as f:
            f.write(gitignore_content)