"""Deployment package generation for converted MCP servers."""

import json
import os
import stat
from datetime import datetime
from pathlib import Path
from typing import Any, Dict

import structlog

from .. import __version__

logger = structlog.get_logger(__name__)


class DeploymentPackageGenerator:
    """Generates complete MCP server deployment package."""

    def __init__(self, output_dir: str):
        """Initialize package generator with output directory."""
        self.output_dir = output_dir

    async def create_deployment_package(self, server_config: Dict[str, Any]) -> str:
        """Create complete deployment package with all necessary files."""
        try:
            logger.info("Creating deployment package", output_dir=self.output_dir)

            # Generate main server files
            await self._generate_server_main(server_config)
            await self._generate_configuration_files(server_config)
            await self._generate_startup_scripts(server_config)

            # Generate documentation and examples
            await self._generate_readme(server_config)
            await self._generate_usage_examples(server_config)

            # Generate deployment configurations
            await self._generate_requirements_file(server_config)
            await self._generate_docker_config(server_config)
            await self._generate_systemd_service(server_config)

            # Generate environment and gitignore files
            await self._generate_env_file(server_config)
            await self._generate_gitignore()

            logger.info("Deployment package created successfully")
            return self.output_dir

        except Exception as e:
            logger.error("Failed to create deployment package", error=str(e))
            raise

    async def _generate_server_main(self, config: Dict[str, Any]):
        """Generate main MCP server implementation."""
        server_template = '''#!/usr/bin/env python3
"""
Generated MCP Server for {api_title}

This file was automatically generated by swagger-mcp-server
from the Swagger specification: {swagger_file}

Generated on: {generation_date}
API Version: {api_version}
"""

import sys
import logging
import warnings
import os
from pathlib import Path
from typing import Optional

# Redirect stderr to devnull BEFORE any imports that might log
_devnull = open(os.devnull, 'w')
sys.stderr = _devnull

# Suppress all warnings and debug output
warnings.filterwarnings("ignore")
os.environ["PYTHONWARNINGS"] = "ignore"

# Disable all logging to prevent debug output
logging.disable(logging.CRITICAL)
# Also set root logger level to prevent any output
logging.getLogger().setLevel(logging.CRITICAL + 1)

# Suppress structlog output
try:
    import structlog
    structlog.configure(
        processors=[],
        wrapper_class=structlog.make_filtering_bound_logger(logging.CRITICAL),
        context_class=dict,
        logger_factory=structlog.PrintLoggerFactory(_devnull),
        cache_logger_on_first_use=False,
    )
except ImportError:
    pass

# Add the swagger_mcp_server package to Python path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

try:
    from mcp.server.fastmcp import FastMCP
    from swagger_mcp_server.storage.database import DatabaseManager, DatabaseConfig
    from swagger_mcp_server.storage.repositories import (
        EndpointRepository,
        MetadataRepository,
        SchemaRepository,
    )
except ImportError as e:
    sys.exit(1)

# Global database manager
db_manager = None
_initialized = False

async def ensure_initialized():
    """Ensure database is initialized (lazy initialization)."""
    global db_manager, _initialized

    if _initialized:
        return

    try:
        # Initialize database with correct path
        database_path = str(Path(__file__).parent / "data" / "mcp_server.db")

        db_config = DatabaseConfig(
            database_path=database_path,
            vacuum_on_startup=False
        )
        db_manager = DatabaseManager(db_config)
        await db_manager.initialize()

        _initialized = True

    except Exception as e:
        raise

def create_server() -> FastMCP:
    """Create and configure the MCP server."""
    mcp = FastMCP("{server_name}")

    @mcp.tool()
    async def searchEndpoints(
        query: str,
        method: Optional[str] = None,
        limit: int = 10
    ) -> str:
        """Search API endpoints by keyword, HTTP method, or path pattern.

        Args:
            query: Search query (keywords, endpoint path, description)
            method: HTTP method filter (GET, POST, PUT, DELETE, etc.)
            limit: Maximum number of results to return (1-100)
        """
        await ensure_initialized()
        global db_manager

        try:
            # Create repository with database session
            async with db_manager.get_session() as session:
                endpoint_repo = EndpointRepository(session)
                endpoints = await endpoint_repo.search_endpoints(
                    query=query,
                    methods=[method] if method else None,
                    limit=min(limit, 100)
                )

            results = []
            for endpoint in endpoints:
                results.append({{
                    "id": endpoint.id,
                    "path": endpoint.path,
                    "method": endpoint.method,
                    "summary": endpoint.summary,
                    "description": endpoint.description,
                    "operationId": endpoint.operation_id
                }})

            # Format detailed response
            response = f"Found {{len(results)}} endpoints:\\n\\n"
            for i, r in enumerate(results[:10], 1):
                response += f"{{i}}. **{{r['method']}} {{r['path']}}**\\n"
                if r['summary']:
                    response += f"   Summary: {{r['summary']}}\\n"
                if r['operationId']:
                    response += f"   Operation ID: {{r['operationId']}}\\n"
                response += f"   Endpoint ID: {{r['id']}} (use this with getExample)\\n"
                response += "\\n"

            if len(results) > 10:
                response += f"... and {{len(results) - 10}} more endpoints\\n"

            return response

        except Exception as e:
            return f"Error searching endpoints: {{str(e)}}"

    @mcp.tool()
    async def getSchema(
        schema_name: str,
        include_examples: bool = True
    ) -> str:
        """Get detailed schema definition for API components.

        Args:
            schema_name: Name of the schema/component to retrieve.
                        Note: Schema names may be flattened from nested OpenAPI structures.
                        For example: 'CreateProductCampaignRequestV2ProductCampaignPlacementV2'
                        instead of 'CreateProductCampaignRequest.V2.ProductCampaignPlacement.V2'.
                        Use searchEndpoints to find related schemas, or query the database directly.
            include_examples: Include example values in the schema
        """
        await ensure_initialized()
        global db_manager

        try:
            async with db_manager.get_session() as session:
                schema_repo = SchemaRepository(session)
                schema = await schema_repo.get_by_name(schema_name)

            if not schema:
                # Try to find similar schema names
                async with db_manager.get_session() as session:
                    schema_repo = SchemaRepository(session)
                    similar = await schema_repo.search_schemas(query=schema_name, limit=5)

                if similar:
                    suggestions = "\\n".join([f"  - {{s.name}}" for s in similar[:5]])
                    return f"Schema '{{schema_name}}' not found.\\n\\nDid you mean one of these?\\n{{suggestions}}\\n\\nNote: Schema names are flattened from OpenAPI structure."
                else:
                    return f"Schema '{{schema_name}}' not found. Tip: Schema names may be flattened (e.g., 'TypeNameSubType' instead of 'TypeName.SubType')."

            # Build detailed schema information
            result = f"# Schema: {{schema.name}}\\n\\n"
            result += f"**Type**: {{schema.type}}\\n"

            if schema.description:
                result += f"**Description**: {{schema.description}}\\n"

            # Parse and display properties
            if schema.properties:
                import json
                try:
                    props = json.loads(schema.properties) if isinstance(schema.properties, str) else schema.properties
                    if props:
                        result += f"\\n## Properties ({{len(props)}}):\\n\\n"
                        for prop_name, prop_def in list(props.items())[:20]:  # Limit to 20 properties
                            prop_type = prop_def.get('type', 'unknown')
                            prop_desc = prop_def.get('description', '')
                            result += f"- **{{prop_name}}** ({{prop_type}})"
                            if prop_desc:
                                result += f": {{prop_desc}}"
                            result += "\\n"
                        if len(props) > 20:
                            result += f"\\n... and {{len(props) - 20}} more properties\\n"
                except:
                    pass

            # Display required fields
            if schema.required:
                try:
                    req = json.loads(schema.required) if isinstance(schema.required, str) else schema.required
                    if req:
                        result += f"\\n**Required fields**: {{', '.join(req)}}\\n"
                except:
                    pass

            return result

        except Exception as e:
            return f"Error retrieving schema: {{str(e)}}"

    @mcp.tool()
    async def getExample(
        endpoint_id: str,
        language: str = "curl"
    ) -> str:
        """Generate code examples for API endpoints.

        Args:
            endpoint_id: Endpoint ID (integer) or path (e.g., '/api/client/campaign')
            language: Programming language for the example (curl, javascript, python, typescript)
        """
        await ensure_initialized()
        global db_manager

        try:
            async with db_manager.get_session() as session:
                endpoint_repo = EndpointRepository(session)
                metadata_repo = MetadataRepository(session)

                # Try to parse as integer ID first, otherwise search by path
                endpoint = None

                # Try integer ID (accept both int and string representations)
                try:
                    int_id = int(str(endpoint_id).strip())
                    endpoint = await endpoint_repo.get_by_id(int_id)
                except (ValueError, TypeError):
                    pass

                # If not found by ID, try exact path match
                if not endpoint:
                    # Try to find by exact path match
                    all_endpoints = await endpoint_repo.list(limit=1000)
                    for ep in all_endpoints:
                        if ep.path == endpoint_id or ep.path.strip('/') == str(endpoint_id).strip('/'):
                            endpoint = ep
                            break

                # If still not found, try fuzzy search
                if not endpoint:
                    endpoints = await endpoint_repo.search_endpoints(
                        query=endpoint_id,
                        methods=None,
                        limit=1
                    )
                    if endpoints:
                        endpoint = endpoints[0]

                if not endpoint:
                    return f"Endpoint '{{endpoint_id}}' not found. Try using endpoint ID from searchEndpoints."

                # Get API metadata for base URL
                api_metadata = await metadata_repo.get_by_id(endpoint.api_id)

                # Determine base URL
                base_url = "https://api.example.com"
                if api_metadata:
                    if api_metadata.servers:
                        import json
                        servers = json.loads(api_metadata.servers) if isinstance(api_metadata.servers, str) else api_metadata.servers
                        if servers and len(servers) > 0:
                            base_url = servers[0].get("url", base_url)
                    elif api_metadata.base_url:
                        base_url = api_metadata.base_url

            # Build full URL
            full_url = f"{{base_url}}{{endpoint.path}}"

            # Generate language-specific examples
            example = f"# {{language.upper()}} example for {{endpoint.method}} {{endpoint.path}}\\n\\n"

            if language == "curl":
                example += f"curl -X {{endpoint.method}} '{{full_url}}'"
                if endpoint.method in ["POST", "PUT", "PATCH"]:
                    example += " \\\\\\n"
                    example += "  -H 'Content-Type: application/json' \\\\\\n"
                    example += "  -d '{{}}'"

            elif language == "python":
                example += "import requests\\n\\n"
                example += f"url = '{{full_url}}'\\n"
                if endpoint.method in ["POST", "PUT", "PATCH"]:
                    example += "headers = {{'Content-Type': 'application/json'}}\\n"
                    example += "data = {{}}\\n\\n"
                    example += f"response = requests.{{endpoint.method.lower()}}(url, headers=headers, json=data)\\n"
                else:
                    example += f"response = requests.{{endpoint.method.lower()}}(url)\\n"
                example += "print(response.json())"

            elif language == "javascript":
                example += f"const url = '{{full_url}}';\\n\\n"
                if endpoint.method in ["POST", "PUT", "PATCH"]:
                    example += "fetch(url, {{\\n"
                    example += f"  method: '{{endpoint.method}}',\\n"
                    example += "  headers: {{'Content-Type': 'application/json'}},\\n"
                    example += "  body: JSON.stringify({{}})\\n"
                    example += "}})\\n"
                else:
                    example += f"fetch(url, {{{{ method: '{{endpoint.method}}' }}}})\\n"
                example += "  .then(response => response.json())\\n"
                example += "  .then(data => console.log(data));"

            elif language == "typescript":
                example += f"const url: string = '{{full_url}}';\\n\\n"
                if endpoint.method in ["POST", "PUT", "PATCH"]:
                    example += "const response = await fetch(url, {{\\n"
                    example += f"  method: '{{endpoint.method}}',\\n"
                    example += "  headers: {{'Content-Type': 'application/json'}},\\n"
                    example += "  body: JSON.stringify({{}})\\n"
                    example += "}});\\n\\n"
                else:
                    example += f"const response = await fetch(url, {{{{ method: '{{endpoint.method}}' }}}});\\n\\n"
                example += "const data = await response.json();\\n"
                example += "console.log(data);"

            else:
                example += f"# {{language}} example not implemented yet\\n"
                example += f"# URL: {{full_url}}\\n"
                example += f"# Method: {{endpoint.method}}"

            return example

        except Exception as e:
            return f"Error generating example: {{str(e)}}"

    return mcp

async def main():
    """Main entry point."""
    try:
        # Initialize database first
        await ensure_initialized()

        # Create and run the MCP server
        server = create_server()

        # Run the server
        server.run()

    except Exception as e:
        sys.exit(1)

if __name__ == "__main__":
    # Let FastMCP handle everything - database will initialize on first request
    server = create_server()
    server.run()
'''

        # Generate class name from server name
        server_class_name = self._generate_class_name(config["server_name"])

        server_content = server_template.format(
            api_title=config["api_title"],
            api_version=config["api_version"],
            swagger_file=config["swagger_file"],
            generation_date=config["generation_date"],
            server_name=config["server_name"],
        )

        server_path = os.path.join(self.output_dir, "server.py")
        with open(server_path, "w", encoding="utf-8") as f:
            f.write(server_content)

        # Make executable
        st = os.stat(server_path)
        os.chmod(server_path, st.st_mode | stat.S_IEXEC)

    def _generate_class_name(self, server_name: str) -> str:
        """Generate a valid Python class name from server name."""
        import re

        # Convert to PascalCase
        words = re.findall(r"[a-zA-Z0-9]+", server_name)
        class_name = "".join(word.capitalize() for word in words)
        return class_name + "MCPServer" if class_name else "GeneratedMCPServer"

    async def _generate_configuration_files(self, config: Dict[str, Any]):
        """Generate configuration files."""
        # Server configuration in YAML format
        server_config = {
            "server": {
                "host": config["host"],
                "port": config["port"],
                "name": config["server_name"],
            },
            "api": {
                "title": config["api_title"],
                "version": config["api_version"],
                "description": config.get("api_description", ""),
            },
            "database": {
                "path": os.path.relpath(config["database_path"], self.output_dir),
                "backup_enabled": True,
                "backup_interval": 3600,  # 1 hour
            },
            "search": {
                "index_path": os.path.relpath(
                    config["search_index_path"], self.output_dir
                ),
                "cache_size": 1000,
                "enable_fuzzy": True,
            },
            "logging": {
                "level": "INFO",
                "format": "console",
                "file": None,
            },
            "security": {
                "enable_auth": False,
                "api_key": None,
                "allowed_hosts": ["localhost", "127.0.0.1"],
            },
        }

        config_dir = os.path.join(self.output_dir, "config")
        os.makedirs(config_dir, exist_ok=True)

        # Write YAML config
        config_path = os.path.join(config_dir, "server.yaml")
        try:
            import yaml

            with open(config_path, "w", encoding="utf-8") as f:
                yaml.dump(server_config, f, default_flow_style=False, indent=2)
        except ImportError:
            # Fallback to JSON if PyYAML not available
            config_path = os.path.join(config_dir, "server.json")
            with open(config_path, "w", encoding="utf-8") as f:
                json.dump(server_config, f, indent=2)

    async def _generate_startup_scripts(self, config: Dict[str, Any]):
        """Generate startup scripts for different platforms."""
        # Unix/Linux startup script
        unix_script = f"""#!/bin/bash
# Startup script for {config["server_name"]} MCP Server

set -e

# Change to script directory
cd "$(dirname "$0")"

# Check Python version
python3 --version >/dev/null 2>&1 || {{
    echo "Error: Python 3 is required but not found"
    exit 1
}}

# Check if virtual environment exists
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python3 -m venv venv
fi

# Activate virtual environment
source venv/bin/activate

# Install dependencies
if [ -f "requirements.txt" ]; then
    echo "Installing dependencies..."
    pip install -r requirements.txt
fi

# Start server
echo "Starting {config['api_title']} MCP Server..."
python server.py "$@"
"""

        unix_script_path = os.path.join(self.output_dir, "start.sh")
        with open(unix_script_path, "w", encoding="utf-8") as f:
            f.write(unix_script)

        # Make executable
        st = os.stat(unix_script_path)
        os.chmod(unix_script_path, st.st_mode | stat.S_IEXEC)

        # Windows batch script
        windows_script = f"""@echo off
rem Startup script for {config["server_name"]} MCP Server

cd /d "%~dp0"

rem Check if Python is available
python --version >nul 2>&1
if errorlevel 1 (
    echo Error: Python is required but not found
    exit /b 1
)

rem Check if virtual environment exists
if not exist "venv" (
    echo Creating virtual environment...
    python -m venv venv
)

rem Activate virtual environment
call venv\\Scripts\\activate.bat

rem Install dependencies
if exist "requirements.txt" (
    echo Installing dependencies...
    pip install -r requirements.txt
)

rem Start server
echo Starting {config['api_title']} MCP Server...
python server.py %*
"""

        windows_script_path = os.path.join(self.output_dir, "start.bat")
        with open(windows_script_path, "w", encoding="utf-8") as f:
            f.write(windows_script)

    async def _generate_readme(self, config: Dict[str, Any]):
        """Generate comprehensive README for converted MCP server."""
        readme_template = f"""# MCP Server for {config["api_title"]}

Generated MCP server providing intelligent access to {config["api_title"]} API documentation.

## Overview

This MCP server was automatically generated from your Swagger/OpenAPI specification and provides three main capabilities:

- **ðŸ” Intelligent Endpoint Search**: Find API endpoints by functionality using natural language queries
- **ðŸ“‹ Schema Retrieval**: Get detailed schema definitions with full type information and relationships
- **ðŸ’» Code Generation**: Generate working code examples in multiple programming languages

## Quick Start

### Prerequisites
- Python 3.8 or higher
- pip (Python package installer)

### Option 1: Automatic Setup (Recommended)
```bash
# Unix/Linux/macOS
./start.sh

# Windows
start.bat
```

### Option 2: Manual Setup
```bash
# Create virtual environment
python -m venv venv

# Activate virtual environment
# On Unix/Linux/macOS:
source venv/bin/activate
# On Windows:
venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt

# Start the server
python server.py
```

### Verify Installation
Once started, the server will display:
```
ðŸš€ MCP Server is starting...
ðŸ“Š API: {config["api_title"]} v{config["api_version"]}
ðŸŒ Server URL: http://localhost:{config["port"]}
ðŸ“š Available MCP methods: searchEndpoints, getSchema, getExample
ðŸ¤– AI agents can now connect and query API documentation
```

## API Information

- **API Title**: {config["api_title"]}
- **Version**: {config["api_version"]}
- **Total Endpoints**: {config["endpoint_count"]}
- **Schema Components**: {config["schema_count"]}
- **Generated**: {datetime.fromisoformat(config["generation_date"]).strftime("%Y-%m-%d %H:%M:%S")}

## MCP Methods

### searchEndpoints
Search for API endpoints using natural language queries.

**Parameters:**
- `keywords` (string): Search terms describing the functionality
- `httpMethods` (optional array): Filter by HTTP methods (GET, POST, etc.)
- `tags` (optional array): Filter by OpenAPI tags

**Example:**
```python
# Search for user-related endpoints
results = await client.searchEndpoints("user management")

# Search for authentication endpoints
results = await client.searchEndpoints("login authentication", ["POST"])
```

### getSchema
Retrieve detailed schema definitions with relationships.

**Parameters:**
- `componentName` (string): Name of the schema component
- `maxDepth` (optional number): Maximum relationship depth (1-10)

**Example:**
```python
# Get user schema with dependencies
schema = await client.getSchema("User")

# Get schema with limited depth
schema = await client.getSchema("UserProfile", maxDepth=2)
```

**Important Note on Schema Names:**

Schema names in this MCP server are flattened from nested OpenAPI structures. This means that nested components like `CreateProductCampaignRequest.V2.ProductCampaignPlacement.V2` become `CreateProductCampaignRequestV2ProductCampaignPlacementV2` in the database.

If you encounter "Schema not found" errors:
1. The server will suggest similar schema names automatically
2. Check the exact schema names in your OpenAPI specification's `components.schemas` section
3. Schema names are case-sensitive and concatenated without dots or separators
4. Use `searchEndpoints` to discover related schemas in endpoint responses

### getExample
Generate code examples for API endpoints.

**Parameters:**
- `endpoint` (string): API endpoint path
- `format` (string): Output format (curl, python, javascript, etc.)
- `method` (optional string): HTTP method

**Example:**
```python
# Get cURL example
curl_example = await client.getExample("/api/v1/users/{{id}}", "curl")

# Get Python example
python_example = await client.getExample("/api/v1/users", "python", "POST")
```

## Configuration

Edit `config/server.yaml` to customize server behavior:

```yaml
server:
  host: localhost      # Server host
  port: {config["port"]}            # Server port
  name: {config["server_name"]}

database:
  path: {os.path.relpath(config["database_path"], self.output_dir)}     # SQLite database path
  backup_enabled: true

search:
  index_path: {os.path.relpath(config["search_index_path"], self.output_dir)}  # Search index location
  cache_size: 1000     # Search result cache size
  enable_fuzzy: true   # Enable fuzzy matching

logging:
  level: INFO          # Log level (DEBUG, INFO, WARNING, ERROR)
  format: console      # Log format
```

## Environment Variables

Override configuration with environment variables:

- `MCP_HOST`: Server host (default: localhost)
- `MCP_PORT`: Server port (default: {config["port"]})
- `MCP_DATABASE_PATH`: Database file path

Example:
```bash
export MCP_PORT=9000
python server.py
```

## Deployment

### Local Development
```bash
python server.py
```

### Docker (if Dockerfile is present)
```bash
docker build -t mcp-server-{config["server_name"]} .
docker run -p {config["port"]}:{config["port"]} mcp-server-{config["server_name"]}
```

### Production with systemd (Linux)
```bash
# Copy service file
sudo cp mcp-server.service /etc/systemd/system/

# Enable and start service
sudo systemctl enable mcp-server
sudo systemctl start mcp-server

# Check status
sudo systemctl status mcp-server
```

## Troubleshooting

### Common Issues

**Port already in use:**
```bash
# Check what's using the port
lsof -i :{config["port"]}

# Use a different port
export MCP_PORT=9000
python server.py
```

**Module import errors:**
```bash
# Ensure dependencies are installed
pip install -r requirements.txt

# Check Python path
python -c "import sys; print(sys.path)"
```

**Database errors:**
```bash
# Remove database to regenerate
rm {config["database_path"]}
python server.py
```

**Search index issues:**
```bash
# Remove search index to regenerate
rm -rf {config["search_index_path"]}
python server.py
```

### Debug Mode
Run with verbose logging:
```bash
python server.py --verbose
```

### Performance Tuning
For high-traffic deployments:
1. Increase search cache size in `config/server.yaml`
2. Enable database connection pooling
3. Use a reverse proxy (nginx, Apache)
4. Monitor with the built-in health endpoints

## File Structure

```
{config["server_name"]}/
â”œâ”€â”€ server.py              # Main MCP server
â”œâ”€â”€ start.sh              # Unix startup script
â”œâ”€â”€ start.bat             # Windows startup script
â”œâ”€â”€ requirements.txt      # Python dependencies
â”œâ”€â”€ README.md             # This file
â”œâ”€â”€ config/
â”‚   â””â”€â”€ server.yaml      # Server configuration
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ mcp_server.db    # SQLite database
â”‚   â””â”€â”€ search_index/    # Search index files
â””â”€â”€ docs/
    â””â”€â”€ examples.md      # Usage examples
```

## Support

- **Original Swagger file**: `{config["swagger_file"]}`
- **Generated by**: swagger-mcp-server v{__version__}
- **Documentation**: https://docs.swagger-mcp-server.com
- **Issues**: https://github.com/swagger-mcp-server/issues

## License

This generated MCP server inherits the license from the original Swagger specification.
"""

        readme_path = os.path.join(self.output_dir, "README.md")
        with open(readme_path, "w", encoding="utf-8") as f:
            f.write(readme_template)

    async def _generate_usage_examples(self, config: Dict[str, Any]):
        """Generate detailed usage examples."""
        examples_content = f'''# Usage Examples for {config["api_title"]} MCP Server

This document provides comprehensive examples for using the generated MCP server.

## Connection Examples

### Python MCP Client
```python
import asyncio
from mcp_client import MCPClient

async def main():
    client = MCPClient("http://localhost:{config['port']}")
    await client.connect()

    # Search for endpoints
    results = await client.searchEndpoints("user management")
    print(f"Found {{len(results['results'])}} endpoints")

    # Get schema information
    schema = await client.getSchema("User")
    print(f"User schema: {{schema}}")

    # Generate code example
    example = await client.getExample("/api/v1/users", "python")
    print(f"Python example:\\n{{example}}")

    await client.disconnect()

asyncio.run(main())
```

### JavaScript/Node.js MCP Client
```javascript
const {{ MCPClient }} = require('mcp-client');

async function main() {{
    const client = new MCPClient('http://localhost:{config['port']}');
    await client.connect();

    // Search for endpoints
    const results = await client.searchEndpoints('user management');
    console.log(`Found ${{results.results.length}} endpoints`);

    // Get schema information
    const schema = await client.getSchema('User');
    console.log('User schema:', schema);

    // Generate code example
    const example = await client.getExample('/api/v1/users', 'javascript');
    console.log('JavaScript example:\\n', example);

    await client.disconnect();
}}

main().catch(console.error);
```

## Search Examples

### Basic Endpoint Search
```python
# Search for user-related functionality
results = await client.searchEndpoints("user profile management")

# Search for authentication endpoints
auth_results = await client.searchEndpoints("login logout authentication")

# Search for file operations
file_results = await client.searchEndpoints("upload download file")
```

### Filtered Search
```python
# Only GET endpoints
get_endpoints = await client.searchEndpoints(
    "user data",
    httpMethods=["GET"]
)

# Only POST and PUT endpoints
modify_endpoints = await client.searchEndpoints(
    "user creation update",
    httpMethods=["POST", "PUT"]
)

# Search by tags
tagged_endpoints = await client.searchEndpoints(
    "user management",
    tags=["users", "admin"]
)
```

### Advanced Search Patterns
```python
# Search for specific functionality
payment_endpoints = await client.searchEndpoints("payment processing checkout")
notification_endpoints = await client.searchEndpoints("notification email sms")
reporting_endpoints = await client.searchEndpoints("reports analytics statistics")

# Search for CRUD operations
crud_examples = [
    await client.searchEndpoints("create new user", ["POST"]),
    await client.searchEndpoints("get user details", ["GET"]),
    await client.searchEndpoints("update user profile", ["PUT", "PATCH"]),
    await client.searchEndpoints("delete user account", ["DELETE"])
]
```

## Schema Examples

### Basic Schema Retrieval
```python
# Get complete schema with all relationships
user_schema = await client.getSchema("User")

# Get schema with limited depth to avoid deep nesting
profile_schema = await client.getSchema("UserProfile", maxDepth=2)

# Get multiple related schemas
schemas = []
for schema_name in ["User", "Address", "ContactInfo"]:
    schema = await client.getSchema(schema_name)
    schemas.append(schema)
```

### Working with Schema Data
```python
# Extract schema properties
user_schema = await client.getSchema("User")
properties = user_schema.get("schema", {{}}).get("properties", {{}})

print("User properties:")
for prop_name, prop_def in properties.items():
    prop_type = prop_def.get("type", "unknown")
    required = prop_name in user_schema.get("schema", {{}}).get("required", [])
    print(f"  {{prop_name}}: {{prop_type}} {{'(required)' if required else ''}}")
```

## Code Generation Examples

### cURL Examples
```python
# GET request example
curl_get = await client.getExample("/api/v1/users/{{id}}", "curl", "GET")
print(curl_get)
# Output: curl -X GET "http://api.example.com/api/v1/users/123" -H "Accept: application/json"

# POST request example
curl_post = await client.getExample("/api/v1/users", "curl", "POST")
print(curl_post)
# Output: curl -X POST "http://api.example.com/api/v1/users" -H "Content-Type: application/json" -d '{{"name": "John Doe", "email": "john@example.com"}}'
```

### Python Examples
```python
# Python requests example
python_example = await client.getExample("/api/v1/users", "python", "POST")
print(python_example)
# Output:
# import requests
#
# url = "http://api.example.com/api/v1/users"
# payload = {{"name": "John Doe", "email": "john@example.com"}}
# response = requests.post(url, json=payload)
# print(response.json())
```

### JavaScript Examples
```python
# JavaScript fetch example
js_example = await client.getExample("/api/v1/users/{{id}}", "javascript", "GET")
print(js_example)
# Output:
# fetch('http://api.example.com/api/v1/users/123', {{
#   method: 'GET',
#   headers: {{
#     'Accept': 'application/json'
#   }}
# }})
# .then(response => response.json())
# .then(data => console.log(data));
```

## Integration Patterns

### AI Agent Integration
```python
class APIAssistant:
    def __init__(self, mcp_client):
        self.client = mcp_client

    async def find_endpoint_for_task(self, task_description):
        """Find the best endpoint for a given task."""
        results = await self.client.searchEndpoints(task_description)

        if results['results']:
            best_match = results['results'][0]  # Highest ranked result

            # Get code example for the endpoint
            example = await self.client.getExample(
                best_match['path'],
                "python",
                best_match['method']
            )

            return {{
                'endpoint': best_match,
                'code_example': example,
                'confidence': best_match.get('score', 0)
            }}

        return None

# Usage
assistant = APIAssistant(mcp_client)
result = await assistant.find_endpoint_for_task("create a new user account")
```

### Batch Processing
```python
async def process_multiple_queries(client, queries):
    """Process multiple search queries efficiently."""
    tasks = []

    for query in queries:
        task = client.searchEndpoints(query)
        tasks.append(task)

    results = await asyncio.gather(*tasks)

    return dict(zip(queries, results))

# Example usage
queries = [
    "user authentication",
    "file upload",
    "payment processing",
    "email notifications"
]

batch_results = await process_multiple_queries(client, queries)
```

## Error Handling

### Connection Errors
```python
from mcp_client import MCPClient, ConnectionError

async def robust_connection():
    client = MCPClient("http://localhost:{config['port']}")

    try:
        await client.connect()
        return client
    except ConnectionError:
        print("Server not running. Please start the MCP server first.")
        return None
    except Exception as e:
        print(f"Unexpected connection error: {{e}}")
        return None
```

### Query Errors
```python
async def safe_search(client, query):
    try:
        results = await client.searchEndpoints(query)
        return results
    except ValueError as e:
        print(f"Invalid query: {{e}}")
        return {{'results': [], 'error': str(e)}}
    except Exception as e:
        print(f"Search error: {{e}}")
        return {{'results': [], 'error': str(e)}}
```

## Performance Tips

### Connection Pooling
```python
class MCPPool:
    def __init__(self, server_url, pool_size=5):
        self.server_url = server_url
        self.pool_size = pool_size
        self.clients = []
        self.available = asyncio.Queue()

    async def initialize(self):
        for _ in range(self.pool_size):
            client = MCPClient(self.server_url)
            await client.connect()
            self.clients.append(client)
            await self.available.put(client)

    async def get_client(self):
        return await self.available.get()

    async def return_client(self, client):
        await self.available.put(client)
```

### Caching Results
```python
from functools import lru_cache
import asyncio

class CachedMCPClient:
    def __init__(self, client):
        self.client = client
        self.schema_cache = {{}}

    async def searchEndpoints(self, query, **kwargs):
        # Searches are dynamic, don't cache
        return await self.client.searchEndpoints(query, **kwargs)

    async def getSchema(self, component_name, max_depth=None):
        cache_key = f"{{component_name}}:{{max_depth}}"

        if cache_key not in self.schema_cache:
            result = await self.client.getSchema(component_name, max_depth)
            self.schema_cache[cache_key] = result

        return self.schema_cache[cache_key]
```

This completes the usage examples for your generated MCP server.
'''

        docs_dir = os.path.join(self.output_dir, "docs")
        os.makedirs(docs_dir, exist_ok=True)

        examples_path = os.path.join(docs_dir, "examples.md")
        with open(examples_path, "w", encoding="utf-8") as f:
            f.write(examples_content)

    async def _generate_requirements_file(self, config: Dict[str, Any]):
        """Generate Python requirements file."""
        requirements = [
            "# Generated requirements for MCP Server",
            f"# API: {config['api_title']} v{config['api_version']}",
            f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "# Core MCP Server dependencies",
            "mcp>=1.0.0",
            "swagger-mcp-server>=0.1.0",
            "",
            "# Optional dependencies for enhanced functionality",
            "pyyaml>=6.0.1  # For YAML configuration files",
            "uvloop>=0.17.0  # For improved async performance (Unix only)",
            "",
            "# Development dependencies (optional)",
            "# pytest>=7.4.0",
            "# pytest-asyncio>=0.21.0",
            "# black>=23.0.0",
            "# mypy>=1.0.0",
        ]

        requirements_path = os.path.join(self.output_dir, "requirements.txt")
        with open(requirements_path, "w", encoding="utf-8") as f:
            f.write("\n".join(requirements))

    async def _generate_docker_config(self, config: Dict[str, Any]):
        """Generate Docker configuration."""
        dockerfile_content = f"""# Dockerfile for {config["api_title"]} MCP Server
# Generated by swagger-mcp-server

FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash mcp
RUN chown -R mcp:mcp /app
USER mcp

# Expose port
EXPOSE {config["port"]}

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
    CMD python -c "import requests; requests.get('http://localhost:{config["port"]}/health')" || exit 1

# Run server
CMD ["python", "server.py"]
"""

        dockerfile_path = os.path.join(self.output_dir, "Dockerfile")
        with open(dockerfile_path, "w", encoding="utf-8") as f:
            f.write(dockerfile_content)

        # Docker Compose file
        compose_content = f"""version: '3.8'

services:
  mcp-server:
    build: .
    container_name: {config["server_name"]}-mcp
    ports:
      - "{config["port"]}:{config["port"]}"
    environment:
      - MCP_HOST=0.0.0.0
      - MCP_PORT={config["port"]}
    volumes:
      - ./data:/app/data
      - ./config:/app/config
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:{config["port"]}/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Optional: Add a reverse proxy
  # nginx:
  #   image: nginx:alpine
  #   ports:
  #     - "80:80"
  #   volumes:
  #     - ./nginx.conf:/etc/nginx/nginx.conf
  #   depends_on:
  #     - mcp-server
"""

        compose_path = os.path.join(self.output_dir, "docker-compose.yml")
        with open(compose_path, "w", encoding="utf-8") as f:
            f.write(compose_content)

    async def _generate_systemd_service(self, config: Dict[str, Any]):
        """Generate systemd service file."""
        service_content = f"""[Unit]
Description={config["api_title"]} MCP Server
After=network.target
Wants=network.target

[Service]
Type=simple
User=mcp
Group=mcp
WorkingDirectory=/opt/{config["server_name"]}
Environment=PATH=/opt/{config["server_name"]}/venv/bin
ExecStart=/opt/{config["server_name"]}/venv/bin/python server.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=10

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/{config["server_name"]}/data

# Environment variables
Environment=MCP_HOST=0.0.0.0
Environment=MCP_PORT={config["port"]}

[Install]
WantedBy=multi-user.target
"""

        service_path = os.path.join(self.output_dir, "mcp-server.service")
        with open(service_path, "w", encoding="utf-8") as f:
            f.write(service_content)

    async def _generate_env_file(self, config: Dict[str, Any]):
        """Generate environment variables template."""
        env_content = f"""# Environment variables for {config["api_title"]} MCP Server
# Copy this file to .env and customize as needed

# Server configuration
MCP_HOST=localhost
MCP_PORT={config["port"]}

# Database configuration
MCP_DATABASE_PATH={config["database_path"]}

# Logging configuration
MCP_LOG_LEVEL=INFO
MCP_LOG_FORMAT=console

# Security configuration (optional)
# MCP_API_KEY=your-secret-api-key
# MCP_ALLOWED_HOSTS=localhost,127.0.0.1,your-domain.com

# Performance tuning (optional)
# MCP_SEARCH_CACHE_SIZE=1000
# MCP_MAX_CONNECTIONS=100
"""

        env_path = os.path.join(self.output_dir, ".env.example")
        with open(env_path, "w", encoding="utf-8") as f:
            f.write(env_content)

    async def _generate_gitignore(self):
        """Generate .gitignore file."""
        gitignore_content = """# Generated MCP Server .gitignore

# Environment variables
.env

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
env/
ENV/

# Database files
*.db
*.sqlite
*.sqlite3

# Search index
search_index/

# Logs
*.log
logs/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Temporary files
tmp/
temp/
*.tmp
"""

        gitignore_path = os.path.join(self.output_dir, ".gitignore")
        with open(gitignore_path, "w", encoding="utf-8") as f:
            f.write(gitignore_content)
